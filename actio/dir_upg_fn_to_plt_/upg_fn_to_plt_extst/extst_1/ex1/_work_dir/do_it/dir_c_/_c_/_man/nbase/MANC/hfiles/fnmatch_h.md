### UP
[fnmatch.h](##fnmatch.h)
[MAIN](##MAIN)
[MAIN_ru](##MAIN_ru)
[ANCORS](##ANCORS)
[ISU](##ISU)
[inet](##A_inet)
[inet](##books_inet)
[inet](##examples_inet)
[inet](##classic_inet)
[inet](##enters_inet)
[inet](##issue_code_inet)
[H_FILE](##H_FILE)
[H_SYNOPSIS](##H_SYNOPSIS)
[H_BUGS](##H_BUGS)
[H_DESCRIPTION_ru](##H_DESCRIPTION_ru)
[H_DESCRIPTION](##H_DESCRIPTION)
[H_ERRORS](##H_ERRORS)
[H_MIRRORS](##H_MIRRORS)
[H_EXAMPLES](##H_EXAMPLES)
[H_CODE_h](##H_CODE_h)
[H_CODE_c](##H_CODE_c)
[H_CODE_m](##H_CODE_m)
[H_BOOKS](##H_BOOKS)
[H_BOOKS_ru](##H_BOOKS_ru)
[H_SUBSTANCES](##H_SUBSTANCES)

[cat_hfiles](../cat_hfiles.md)
[cat_utils](../cat_utils.md)
[cat_structs](../cat_structs.md)
[cat_param](../cat_params.md)
[cat_macros](../cat_macross.md)
[cat_const](../cat_consts.md)
[cat_type](../cat_types.md)
[cat_any](../cat_anys.md)

[UP](###UP)
## MAIN
:fnmatch.h:
[next](##MAIN_ru)

<<MAIN>>
[MAIN](../fills/fnmatch_h/MAIN)


[UP](###UP)
## MAIN_ru
:fnmatch.h:
[next](##ANCORS)

<<MAIN_ru>>
[MAIN_ru](../fills/fnmatch_h/MAIN_ru)


[UP](###UP)
## ANCORS
:fnmatch.h:
[next](##ISU)

<<ANCORS>>
[ANCORS](../fills/fnmatch_h/ANCORS)


[UP](###UP)
## ISU
:fnmatch.h:
[next](##H_FILE)

<<ISU>>
only read
:fnmatch.h:
[ISU](../contents)
[next](##inet)


[UP](###UP)
## inet
:fnmatch.h:
[next](##H_FILE)

[UP](###UP)
## A_inet
[manpages.org](https://www.google.ru/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Fmanpages.org)
[reposcope.com_ru](https://www.google.ru/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Freposcope.com%2Fmanpages%2Fru)
[pubs.opengroup.org](https://www.google.com/search?q=fnmatch.h+https%3A%2F%2Fpubs.opengroup.org)
[manpages.debian.org](https://yandex.ru/search/?text=fnmatch.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[www.opennet.ru](http://www.opennet.ru/man.shtml?category=2&topic=fnmatch.h)
[man7.org](https://www.google.ru/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Fman7.org%2Flinux%2Fman-pages)
[en.cppreference.com](https://www.google.com/search?q=fnmatch.h+en.cppreference.com)
[www.mankier.com](https://www.mankier.com/?q=fnmatch.h)
[www.codecogs.com](https://www.google.ru/search?q=fnmatch.h+https%3A%2F%2Fwww.codecogs.com%2Flibrary%2Fcomputing%2F)
[digitalmars.com](https://www.google.ru/search?q=fnmatch.h+https%3A%2F%2Fdigitalmars.com%2Frtl%2F)


[UP](###UP)
## books_inet
[cpp.com.ru](https://yandex.ru/search/?text=fnmatch.h+site%3Ahttps%3A%2F%2Fcpp.com.ru)
[linuxhint.com](https://www.google.ru/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Flinuxhint.com)
[gnu.org](https://www.google.ru/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2Fmanual)

[UP](###UP)
## examples_inet
[yandex:examples](https://yandex.ru/search/?text=fnmatch.h+example+in+c)
[docs.oracle.com](https://www.google.com/search?q=fnmatch.h+https%3A%2F%2Fdocs.oracle.com)
[manpages.debian.org](https://yandex.ru/search/?text=fnmatch.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[osr507doc.xinuos.com](https://www.google.com/search?q=fnmatch.h+http%3A%2F%2Fosr507doc.xinuos.com%2Fen%2Fman)
[cpp.hotexamples.com](https://cpp.hotexamples.com/examples/-/-/fnmatch.h/cpp-fnmatch.h-function-examples.html)
[all-ht.ru](https://yandex.ru/search/?text=fnmatch.h+site%3Ahttp%3A%2F%2Fall-ht.ru%2Finf%2Fprog%2Fc%2F)
[cppreference.com](https://yandex.ru/search/?text=fnmatch.h+site%3Ahttps%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2F)

[UP](###UP)
## classic_inet
[bogatyrev_c_unix](https://www.google.com/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fbogatyrev_c_unix)
[kr_cbook](https://www.google.com/search?q=fnmatch.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fkr_cbook)

[UP](###UP)
## enters_inet
[pubs.opengroup.org](https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html)

[UP](###UP)
## issue_code_inet
[code.woboq.org](https://www.google.com/search?h=&sitesearch=https%3A%2F%2Fcode.woboq.org%2Fuserspace%2Fglibc%2F&q=fnmatch.h)


[UP](###UP)
## H_FILE [fnmatch_h.md](fnmatch_h.md)
:fnmatch.h:
[next](##H_SYNOPSIS)

[UP](###UP)
## H_SYNOPSIS
:fnmatch.h:
[next](##H_DESCRIPTION_ru)

<<SYNOPSIS>>
[SYNOPSIS](../fills/fnmatch_h/SYNOPSIS)


[UP](###UP)
## H_DESCRIPTION_ru
:fnmatch.h:
[next](##H_DESCRIPTION)

<<DESCRIPTION_ru>>
[DESCRIPTION_ru](../fills/fnmatch_h/DESCRIPTION_ru)


[UP](###UP)
## H_DESCRIPTION
:fnmatch.h:
[next](##H_ERRORS)

<<DESCRIPTION>>
[DESCRIPTION](../fills/fnmatch_h/DESCRIPTION)


[UP](###UP)
## H_ERRORS
:fnmatch.h:
[next](##H_MIRRORS)

<<ERRORS>>
[ERRORS](../fills/fnmatch_h/ERRORS)


[UP](###UP)
## H_MIRRORS
:fnmatch.h:
[next](##H_BUGS)

<<MIRRORS>>
[MIRRORS](../fills/fnmatch_h/MIRRORS)


[UP](###UP)
## H_BUGS
:fnmatch.h:
[next](##H_EXAMPLES)

<<BUGS>>
[BUGS](../fills/fnmatch_h/BUGS)


[UP](###UP)
## H_EXAMPLES
:fnmatch.h:
[next](##H_CODE)

<<EXAMPLES>>
[EXAMPLES](../fills/fnmatch_h/EXAMPLES)


[UP](###UP)
## H_CODE_h
:fnmatch.h:
[next](##H_CODE_c)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/posix/fnmatch.h.html
#ifndef        _FNMATCH_H
#define        _FNMATCH_H        1
#ifdef        __cplusplus
extern "C" {
#endif
/* We #undef these before defining them because some losing systems
(HP-UX A.08.07 for example) define these in <unistd.h>.  */
#undef        FNM_PATHNAME
#undef        FNM_NOESCAPE
#undef        FNM_PERIOD
/* Bits set in the FLAGS argument to `fnmatch'.  */
#define        FNM_PATHNAME        (1 << 0) /* No wildcard can ever match `/'.  */
#define        FNM_NOESCAPE        (1 << 1) /* Backslashes don't quote special chars.  */
#define        FNM_PERIOD        (1 << 2) /* Leading `.' is matched only explicitly.  */
#if !defined _POSIX_C_SOURCE || _POSIX_C_SOURCE < 2 || defined _GNU_SOURCE
# define FNM_FILE_NAME         FNM_PATHNAME        /* Preferred GNU name.  */
# define FNM_LEADING_DIR (1 << 3)        /* Ignore `/...' after a match.  */
# define FNM_CASEFOLD         (1 << 4)        /* Compare without regard to case.  */
# define FNM_EXTMATCH         (1 << 5)        /* Use ksh-like extended matching. */
#endif
/* Value returned by `fnmatch' if STRING does not match PATTERN.  */
#define        FNM_NOMATCH        1
/* This value is returned if the implementation does not support
`fnmatch'.  Since this is not the case here it will never be
returned but the conformance test suites still require the symbol
to be defined.  */
#ifdef _XOPEN_SOURCE
# define FNM_NOSYS        (-1)
#endif
/* Match NAME against the filename pattern PATTERN,
returning zero if it matches, FNM_NOMATCH if not.  */
extern int fnmatch (const char *__pattern, const char *__name, int __flags);
#ifdef        __cplusplus
}
#endif
#endif /* fnmatch.h */
-------------------------------------- 
----------------------------------------------------- 
<<CODE_h>>
[CODE_h](../fills/fnmatch_h/CODE_h)


[UP](###UP)
## H_CODE_c
:fnmatch.h:
[next](##H_CODE_m)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/posix/fnmatch.c.html
#if HAVE_CONFIG_H
# include <config.h>
#endif
/* Enable GNU extensions in fnmatch.h.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE        1
#endif
#include <assert.h>
#include <errno.h>
#include <fnmatch.h>
#include <ctype.h>
#include <string.h>
#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#endif
#ifdef _LIBC
# include <alloca.h>
#else
# define alloca_account(size., var) alloca (size)
#endif
/* For platform which support the ISO C amendement 1 functionality we
support user defined character classes.  */
#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
# include <wchar.h>
# include <wctype.h>
#endif
/* We need some of the locale data (the collation sequence information)
but there is no interface to get this information in general.  Therefore
we support a correct implementation only in glibc.  */
#ifdef _LIBC
# include "../locale/localeinfo.h"
# include "../locale/coll-lookup.h"
# include <shlib-compat.h>
# define CONCAT(a,b) __CONCAT(a,b)
# define mbsrtowcs __mbsrtowcs
# define fnmatch __fnmatch
extern int fnmatch (const char *pattern, const char *string, int flags);
#endif
/* We often have to test for FNM_FILE_NAME and FNM_PERIOD being both set.  */
#define NO_LEADING_PERIOD(flags) 
((flags & (FNM_FILE_NAME | FNM_PERIOD)) == (FNM_FILE_NAME | FNM_PERIOD))
/* Comment out all this code if we are using the GNU C Library, and are not
actually compiling the library itself.  This code is part of the GNU C
Library, but also included in many other GNU distributions.  Compiling
and linking in this code is a waste when using the GNU C library
(especially if it is a shared library).  Rather than having every GNU
program understand `configure --with-gnu-libc' and omit the object files,
it is simpler to just do this in the source for each such file.  */
#if defined _LIBC || !defined __GNU_LIBRARY__
# if defined STDC_HEADERS || !defined isascii
#  define ISASCII(c) 1
# else
#  define ISASCII(c) isascii(c)
# endif
# ifdef isblank
#  define ISBLANK(c) (ISASCII (c) && isblank (c))
# else
#  define ISBLANK(c) ((c) == ' ' || (c) == '	')
# endif
# ifdef isgraph
#  define ISGRAPH(c) (ISASCII (c) && isgraph (c))
# else
#  define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
# endif
# define ISPRINT(c) (ISASCII (c) && isprint (c))
# define ISDIGIT(c) (ISASCII (c) && isdigit (c))
# define ISALNUM(c) (ISASCII (c) && isalnum (c))
# define ISALPHA(c) (ISASCII (c) && isalpha (c))
# define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
# define ISLOWER(c) (ISASCII (c) && islower (c))
# define ISPUNCT(c) (ISASCII (c) && ispunct (c))
# define ISSPACE(c) (ISASCII (c) && isspace (c))
# define ISUPPER(c) (ISASCII (c) && isupper (c))
# define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
# define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
# if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
/* The GNU C library provides support for user-defined character classes
and the functions from ISO C amendement 1.  */
#  ifdef CHARCLASS_NAME_MAX
#   define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
#  else
/* This shouldn't happen but some implementation might still have this
problem.  Use a reasonable default value.  */
#   define CHAR_CLASS_MAX_LENGTH 256
#  endif
#  ifdef _LIBC
#   define IS_CHAR_CLASS(string) __wctype (string)
#  else
#   define IS_CHAR_CLASS(string) wctype (string)
#  endif
#  ifdef _LIBC
#   define ISWCTYPE(WC, WT)        __iswctype (WC, WT)
#  else
#   define ISWCTYPE(WC, WT)        iswctype (WC, WT)
#  endif
#  if (HAVE_MBSTATE_T && HAVE_MBSRTOWCS) || _LIBC
/* In this case we are implementing the multibyte character handling.  */
#   define HANDLE_MULTIBYTE        1
#  endif
# else
#  define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
#  define IS_CHAR_CLASS(string)                                                      
(STREQ (string, "alpha") || STREQ (string, "upper")                              
|| STREQ (string, "lower") || STREQ (string, "digit")                      
|| STREQ (string, "alnum") || STREQ (string, "xdigit")                      
|| STREQ (string, "space") || STREQ (string, "print")                      
|| STREQ (string, "punct") || STREQ (string, "graph")                      
|| STREQ (string, "cntrl") || STREQ (string, "blank"))
# endif
/* Avoid depending on library functions or files
whose names are inconsistent.  */
# if !defined _LIBC && !defined getenv
extern char *getenv ();
# endif
# ifndef errno
extern int errno;
# endif
/* Global variable.  */
static int posixly_correct;
/* This function doesn't exist on most systems.  */
# if !defined HAVE___STRCHRNUL && !defined _LIBC
static char *
__strchrnul (const char *s, int c)
{
char *result = strchr (s, c);
if (result == NULL)
result = strchr (s, '0');
return result;
}
# endif
# if HANDLE_MULTIBYTE && !defined HAVE___STRCHRNUL && !defined _LIBC
static wchar_t *
__wcschrnul (const wchar_t *s, wint_t c)
{
wchar_t *result = wcschr (s, c);
if (result == NULL)
result = wcschr (s, '0');
return result;
}
# endif
/* Note that this evaluates C many times.  */
# ifdef _LIBC
#  define FOLD(c) ((flags & FNM_CASEFOLD) ? tolower (c) : (c))
# else
#  define FOLD(c) ((flags & FNM_CASEFOLD) && ISUPPER (c) ? tolower (c) : (c))
# endif
# define CHAR        char
# define UCHAR        unsigned char
# define INT        int
# define FCT        internal_fnmatch
# define EXT        ext_match
# define END        end_pattern
# define STRUCT        fnmatch_struct
# define L(CS)        CS
# ifdef _LIBC
#  define BTOWC(C)        __btowc (C)
# else
#  define BTOWC(C)        btowc (C)
# endif
# define STRLEN(S) strlen (S)
# define STRCAT(D, S) strcat (D, S)
# define MEMPCPY(D, S, N) __mempcpy (D, S, N)
# define MEMCHR(S, C, N) memchr (S, C, N)
# define STRCOLL(S1, S2) strcoll (S1, S2)
# define WIDE_CHAR_VERSION 0
# include <locale/weight.h>
# define FINDIDX findidx
# include "fnmatch_loop.c"
# if HANDLE_MULTIBYTE
/* Note that this evaluates C many times.  */
#  ifdef _LIBC
#   define FOLD(c) ((flags & FNM_CASEFOLD) ? __towlower (c) : (c))
#  else
#   define FOLD(c) ((flags & FNM_CASEFOLD) && ISUPPER (c) ? towlower (c) : (c))
#  endif
#  define CHAR        wchar_t
#  define UCHAR        wint_t
#  define INT        wint_t
#  define FCT        internal_fnwmatch
#  define EXT        ext_wmatch
#  define END        end_wpattern
#  define STRUCT fnwmatch_struct
#  define L(CS)        L##CS
#  define BTOWC(C)        (C)
#  define STRLEN(S) __wcslen (S)
#  define STRCAT(D, S) __wcscat (D, S)
#  define MEMPCPY(D, S, N) __wmempcpy (D, S, N)
#  define MEMCHR(S, C, N) __wmemchr (S, C, N)
#  define STRCOLL(S1, S2) wcscoll (S1, S2)
#  ifdef _LIBC
#   define WMEMCMP(S1, S2, N) __wmemcmp (S1, S2, N)
#  else
#   define WMEMCMP(S1, S2, N) wmemcmp (S1, S2, N)
#  endif
#  define WIDE_CHAR_VERSION 1
/* Change the name the header defines so it doesn't conflict with
the <locale/weight.h> version included above.  */
#  define findidx findidxwc
#  include <locale/weightwc.h>
#  undef findidx
#  define FINDIDX findidxwc
#  undef IS_CHAR_CLASS
/* We have to convert the wide character string in a multibyte string.  But
we know that the character class names consist of alphanumeric characters
from the portable character set, and since the wide character encoding
for a member of the portable character set is the same code point as
its single-byte encoding, we can use a simplified method to convert the
string to a multibyte character string.  */
static wctype_t
is_char_class (const wchar_t *wcs)
{
char s[CHAR_CLASS_MAX_LENGTH + 1];
char *cp = s;
do
{
/* Test for a printable character from the portable character set.  */
#  ifdef _LIBC
if (*wcs < 0x20 || *wcs > 0x7e
|| *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)
return (wctype_t) 0;
#  else
switch (*wcs)
{
case L' ': case L'!': case L'"': case L'#': case L'%':
case L'&': case L''': case L'(': case L')': case L'*':
case L'+': case L',': case L'-': case L'.': case L'/':
case L'0': case L'1': case L'2': case L'3': case L'4':
case L'5': case L'6': case L'7': case L'8': case L'9':
case L':': case L';': case L'<': case L'=': case L'>':
case L'?':
case L'A': case L'B': case L'C': case L'D': case L'E':
case L'F': case L'G': case L'H': case L'I': case L'J':
case L'K': case L'L': case L'M': case L'N': case L'O':
case L'P': case L'Q': case L'R': case L'S': case L'T':
case L'U': case L'V': case L'W': case L'X': case L'Y':
case L'Z':
case L'[': case L'\': case L']': case L'^': case L'_':
case L'a': case L'b': case L'c': case L'd': case L'e':
case L'f': case L'g': case L'h': case L'i': case L'j':
case L'k': case L'l': case L'm': case L'n': case L'o':
case L'p': case L'q': case L'r': case L's': case L't':
case L'u': case L'v': case L'w': case L'x': case L'y':
case L'z': case L'{': case L'|': case L'}': case L'~':
break;
default:
return (wctype_t) 0;
}
#  endif
/* Avoid overrunning the buffer.  */
if (cp == s + CHAR_CLASS_MAX_LENGTH)
return (wctype_t) 0;
*cp++ = (char) *wcs++;
}
while (*wcs != L'0');
*cp = '0';
#  ifdef _LIBC
return __wctype (s);
#  else
return wctype (s);
#  endif
}
#  define IS_CHAR_CLASS(string) is_char_class (string)
#  include "fnmatch_loop.c"
# endif
int
fnmatch (const char *pattern, const char *string, int flags)
{
# if HANDLE_MULTIBYTE
if (__builtin_expect (MB_CUR_MAX, 1) != 1)
{
mbstate_t ps;
size_t n;
const char *p;
wchar_t *wpattern_malloc = NULL;
wchar_t *wpattern;
wchar_t *wstring_malloc = NULL;
wchar_t *wstring;
size_t alloca_used = 0;
/* Convert the strings into wide characters.  */
memset (&ps, '0', sizeof (ps));
p = pattern;
#ifdef _LIBC
n = __strnlen (pattern, 1024);
#else
n = strlen (pattern);
#endif
if (__glibc_likely (n < 1024))
{
wpattern = (wchar_t *) alloca_account ((n + 1) * sizeof (wchar_t),
alloca_used);
n = mbsrtowcs (wpattern, &p, n + 1, &ps);
if (__glibc_unlikely (n == (size_t) -1))
/* Something wrong.
XXX Do we have to set `errno' to something which mbsrtows hasn't
already done?  */
return -1;
if (p)
{
memset (&ps, '0', sizeof (ps));
goto prepare_wpattern;
}
}
else
{
prepare_wpattern:
n = mbsrtowcs (NULL, &pattern, 0, &ps);
if (__glibc_unlikely (n == (size_t) -1))
/* Something wrong.
XXX Do we have to set `errno' to something which mbsrtows hasn't
already done?  */
return -1;
if (__glibc_unlikely (n >= (size_t) -1 / sizeof (wchar_t)))
{
__set_errno (ENOMEM);
return -2;
}
wpattern_malloc = wpattern
= (wchar_t *) malloc ((n + 1) * sizeof (wchar_t));
assert (mbsinit (&ps));
if (wpattern == NULL)
return -2;
(void) mbsrtowcs (wpattern, &pattern, n + 1, &ps);
}
assert (mbsinit (&ps));
#ifdef _LIBC
n = __strnlen (string, 1024);
#else
n = strlen (string);
#endif
p = string;
if (__glibc_likely (n < 1024))
{
wstring = (wchar_t *) alloca_account ((n + 1) * sizeof (wchar_t),
alloca_used);
n = mbsrtowcs (wstring, &p, n + 1, &ps);
if (__glibc_unlikely (n == (size_t) -1))
{
/* Something wrong.
XXX Do we have to set `errno' to something which
mbsrtows hasn't already done?  */
free_return:
free (wpattern_malloc);
return -1;
}
if (p)
{
memset (&ps, '0', sizeof (ps));
goto prepare_wstring;
}
}
else
{
prepare_wstring:
n = mbsrtowcs (NULL, &string, 0, &ps);
if (__glibc_unlikely (n == (size_t) -1))
/* Something wrong.
XXX Do we have to set `errno' to something which mbsrtows hasn't
already done?  */
goto free_return;
if (__glibc_unlikely (n >= (size_t) -1 / sizeof (wchar_t)))
{
free (wpattern_malloc);
__set_errno (ENOMEM);
return -2;
}
wstring_malloc = wstring
= (wchar_t *) malloc ((n + 1) * sizeof (wchar_t));
if (wstring == NULL)
{
free (wpattern_malloc);
return -2;
}
assert (mbsinit (&ps));
(void) mbsrtowcs (wstring, &string, n + 1, &ps);
}
int res = internal_fnwmatch (wpattern, wstring, wstring + n,
flags & FNM_PERIOD, flags, NULL,
alloca_used);
free (wstring_malloc);
free (wpattern_malloc);
return res;
}
# endif  /* mbstate_t and mbsrtowcs or _LIBC.  */
return internal_fnmatch (pattern, string, string + strlen (string),
flags & FNM_PERIOD, flags, NULL, 0);
}
# ifdef _LIBC
#  undef fnmatch
versioned_symbol (libc, __fnmatch, fnmatch, GLIBC_2_2_3);
#  if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_2_3)
strong_alias (__fnmatch, __fnmatch_old)
compat_symbol (libc, __fnmatch_old, fnmatch, GLIBC_2_0);
#  endif
libc_hidden_ver (__fnmatch, fnmatch)
# endif
#endif        /* _LIBC or not __GNU_LIBRARY__.  */
-------------------------------------- 
----------------------------------------------------- 
<<CODE_c>>
[CODE_c](../fills/fnmatch_h/CODE_c)


[UP](###UP)
## H_CODE_m
:fnmatch.h:
[next](##H_BOOKS)

<<CODE_m>>
[CODE_m](../fills/fnmatch_h/CODE_m)


[UP](###UP)
## H_BOOKS
:fnmatch.h:
[next](##H_BOOKS_ru)

<<BOOKS>>
[BOOKS](../fills/fnmatch_h/BOOKS)


[UP](###UP)
## H_BOOKS_ru
:fnmatch.h:
[next](##H_SUBSTANCES)

<<BOOKS_ru>>
[BOOKS_ru](../fills/fnmatch_h/BOOKS_ru)


[UP](###UP)
## H_SUBSTANCES
:fnmatch.h:
[UP](###UP)
p[fnmatch](../utils/fnmatch/fnmatch.man)
c[FNM_NOESCAPE](../consts/FNM_NOESCAPE/FNM_NOESCAPE.man)
c[FNM_PATHNAME](../consts/FNM_PATHNAME/FNM_PATHNAME.man)
c[FNM_PERIOD](../consts/FNM_PERIOD/FNM_PERIOD.man)
c[FNM_FILE_NAME](../consts/FNM_FILE_NAME/FNM_FILE_NAME.man)
c[FNM_LEADING_DIR](../consts/FNM_LEADING_DIR/FNM_LEADING_DIR.man)
c[FNM_CASEFOLD](../consts/FNM_CASEFOLD/FNM_CASEFOLD.man)
