### UP
[dlfcn.h](##dlfcn.h)
[MAIN](##MAIN)
[MAIN_ru](##MAIN_ru)
[ANCORS](##ANCORS)
[ISU](##ISU)
[inet](##A_inet)
[inet](##books_inet)
[inet](##examples_inet)
[inet](##classic_inet)
[inet](##enters_inet)
[inet](##issue_code_inet)
[H_FILE](##H_FILE)
[H_SYNOPSIS](##H_SYNOPSIS)
[H_BUGS](##H_BUGS)
[H_DESCRIPTION_ru](##H_DESCRIPTION_ru)
[H_DESCRIPTION](##H_DESCRIPTION)
[H_ERRORS](##H_ERRORS)
[H_MIRRORS](##H_MIRRORS)
[H_EXAMPLES](##H_EXAMPLES)
[H_CODE_h](##H_CODE_h)
[H_CODE_c](##H_CODE_c)
[H_CODE_m](##H_CODE_m)
[H_BOOKS](##H_BOOKS)
[H_BOOKS_ru](##H_BOOKS_ru)
[H_SUBSTANCES](##H_SUBSTANCES)

[cat_hfiles](../cat_hfiles.md)
[cat_utils](../cat_utils.md)
[cat_structs](../cat_structs.md)
[cat_param](../cat_params.md)
[cat_macros](../cat_macross.md)
[cat_const](../cat_consts.md)
[cat_type](../cat_types.md)
[cat_any](../cat_anys.md)

[UP](###UP)
## MAIN
:dlfcn.h:
[next](##MAIN_ru)

<<MAIN>>
[MAIN](../fills/dlfcn_h/MAIN)


[UP](###UP)
## MAIN_ru
:dlfcn.h:
[next](##ANCORS)

<<MAIN_ru>>
[MAIN_ru](../fills/dlfcn_h/MAIN_ru)


[UP](###UP)
## ANCORS
:dlfcn.h:
[next](##ISU)

<<ANCORS>>
[ANCORS](../fills/dlfcn_h/ANCORS)


[UP](###UP)
## ISU
:dlfcn.h:
[next](##H_FILE)

<<ISU>>
only read
:dlfcn.h:
[ISU](../contents)
[next](##inet)


[UP](###UP)
## inet
:dlfcn.h:
[next](##H_FILE)

[UP](###UP)
## A_inet
[manpages.org](https://www.google.ru/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Fmanpages.org)
[reposcope.com_ru](https://www.google.ru/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Freposcope.com%2Fmanpages%2Fru)
[pubs.opengroup.org](https://www.google.com/search?q=dlfcn.h+https%3A%2F%2Fpubs.opengroup.org)
[manpages.debian.org](https://yandex.ru/search/?text=dlfcn.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[www.opennet.ru](http://www.opennet.ru/man.shtml?category=2&topic=dlfcn.h)
[man7.org](https://www.google.ru/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Fman7.org%2Flinux%2Fman-pages)
[en.cppreference.com](https://www.google.com/search?q=dlfcn.h+en.cppreference.com)
[www.mankier.com](https://www.mankier.com/?q=dlfcn.h)
[www.codecogs.com](https://www.google.ru/search?q=dlfcn.h+https%3A%2F%2Fwww.codecogs.com%2Flibrary%2Fcomputing%2F)
[digitalmars.com](https://www.google.ru/search?q=dlfcn.h+https%3A%2F%2Fdigitalmars.com%2Frtl%2F)


[UP](###UP)
## books_inet
[cpp.com.ru](https://yandex.ru/search/?text=dlfcn.h+site%3Ahttps%3A%2F%2Fcpp.com.ru)
[linuxhint.com](https://www.google.ru/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Flinuxhint.com)
[gnu.org](https://www.google.ru/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2Fmanual)

[UP](###UP)
## examples_inet
[yandex:examples](https://yandex.ru/search/?text=dlfcn.h+example+in+c)
[docs.oracle.com](https://www.google.com/search?q=dlfcn.h+https%3A%2F%2Fdocs.oracle.com)
[manpages.debian.org](https://yandex.ru/search/?text=dlfcn.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[osr507doc.xinuos.com](https://www.google.com/search?q=dlfcn.h+http%3A%2F%2Fosr507doc.xinuos.com%2Fen%2Fman)
[cpp.hotexamples.com](https://cpp.hotexamples.com/examples/-/-/dlfcn.h/cpp-dlfcn.h-function-examples.html)
[all-ht.ru](https://yandex.ru/search/?text=dlfcn.h+site%3Ahttp%3A%2F%2Fall-ht.ru%2Finf%2Fprog%2Fc%2F)
[cppreference.com](https://yandex.ru/search/?text=dlfcn.h+site%3Ahttps%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2F)

[UP](###UP)
## classic_inet
[bogatyrev_c_unix](https://www.google.com/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fbogatyrev_c_unix)
[kr_cbook](https://www.google.com/search?q=dlfcn.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fkr_cbook)

[UP](###UP)
## enters_inet
[pubs.opengroup.org](https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html)

[UP](###UP)
## issue_code_inet
[code.woboq.org](https://www.google.com/search?h=&sitesearch=https%3A%2F%2Fcode.woboq.org%2Fuserspace%2Fglibc%2F&q=dlfcn.h)


[UP](###UP)
## H_FILE [dlfcn_h.md](dlfcn_h.md)
:dlfcn.h:
[next](##H_SYNOPSIS)

[UP](###UP)
## H_SYNOPSIS
:dlfcn.h:
[next](##H_DESCRIPTION_ru)

<<SYNOPSIS>>
[SYNOPSIS](../fills/dlfcn_h/SYNOPSIS)


[UP](###UP)
## H_DESCRIPTION_ru
:dlfcn.h:
[next](##H_DESCRIPTION)

----------------------------------------------------- 
-------------------------------------- 
Иногда на этапе выполнения программы требуется загрузить некоторый код без явной
компоновки. Рассмотрим приложение, поддерживающее подключаемые модули: Web-броузер.
Архитектура броузера позволяет сторонним разработчикам создавать дополнительные модули,
расширяющие функциональные возможности броузера. Модуль реализуется в виде совместно
используемой библиотеки и размещается в заранее известном каталоге. Броузер автоматически
загружает код из этого каталога.
Для этих целей в Linux существует специальная функция dlopen(). Например, открыть
библиотеку libtest.so можно следующим образом:
dlopen("libtest.so", RTLD_LAZY)
Второй параметр это флаг, определяющий способ привязки символических констант в
библиотеке. Данная установка подходит в большинстве случаев. Подробнее узнать о ней можно
в документации.
Объявление функций работы с динамическими библиотеками находится в файле
<dlfcn.h>. Использующие их программы должны компоноваться с флагом -ldl,
обеспечивающим подключение библиотеки libdl.
Функция dlopen() возвращает значение типа void*, используемое в качестве дескриптора
динамической библиотеки. Это значение можно передавать функции dlsym(), которая
возвращает адрес функции, загружаемой из библиотеки. Например, если в библиотеке
libtest.so определена функция my_function(), то она вызывается следующим образом:
void* handle = dlopen("libtest.so", RTLD_LAZY);
void (*test)() = dlsym(handle, "my_function");
(*test)();
dlclose(handle);
С помощью функции dlsym() можно также получить указатель на статическую
переменную, содержащуюся в совместно используемой библиотеке.
Обе функции, dlopen() и dlsym(), в случае неудачного завершения возвращают NULL. В
данной ситуации можно вызвать функцию dlerror() (без параметров), чтобы получить
текстовое описание возникшей ошибки.
Функция dlclose() выгружает совместно используемую библиотеку. Строго говоря,
функция dlopen() загружает библиотеку лишь в том случае, если она еще не находится в
памяти. В противном случае просто увеличивается число ссылок на файл. Аналогичным образом
функция dlclose() сначала уменьшает счетчик ссылок, и только если он становится равным
нулю, выгружает библиотеку.
Когда совместно используемая библиотека пишется на C++, имеет смысл объявлять
общедоступные функции со спецификатором extern "С". Например, если функция
my_function() написана на C++ и находится в совместно используемой библиотеке, а нужно
обеспечить доступ к ней с помощью функции dlsym(), объявите ее следующим образом:
extern "С" void my_function();
Тем самым компилятору C++ будет запрещено подменять имя функции. При отсутствии
спецификатора extern "С" компилятор подставит вместо имени my_function совершенно
другое имя, в котором закодирована информация о данной функции. Компилятор языка С не
заменяет имена; он работает с теми именами, которые назначены пользователем.
-------------------------------------- 
----------------------------------------------------- 
<<DESCRIPTION_ru>>
[DESCRIPTION_ru](../fills/dlfcn_h/DESCRIPTION_ru)


[UP](###UP)
## H_DESCRIPTION
:dlfcn.h:
[next](##H_ERRORS)

<<DESCRIPTION>>
[DESCRIPTION](../fills/dlfcn_h/DESCRIPTION)


[UP](###UP)
## H_ERRORS
:dlfcn.h:
[next](##H_MIRRORS)

<<ERRORS>>
[ERRORS](../fills/dlfcn_h/ERRORS)


[UP](###UP)
## H_MIRRORS
:dlfcn.h:
[next](##H_BUGS)

<<MIRRORS>>
[MIRRORS](../fills/dlfcn_h/MIRRORS)


[UP](###UP)
## H_BUGS
:dlfcn.h:
[next](##H_EXAMPLES)

<<BUGS>>
[BUGS](../fills/dlfcn_h/BUGS)


[UP](###UP)
## H_EXAMPLES
:dlfcn.h:
[next](##H_CODE)

<<EXAMPLES>>
[EXAMPLES](../fills/dlfcn_h/EXAMPLES)


[UP](###UP)
## H_CODE_h
:dlfcn.h:
[next](##H_CODE_c)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/dlfcn/dlfcn.h.html
#ifndef        _DLFCN_H
#define        _DLFCN_H 1
#include <features.h>
#define __need_size_t
#include <stddef.h>
/* Collect various system dependent definitions and declarations.  */
#include <bits/dlfcn.h>
#ifdef __USE_GNU
/* If the first argument of `dlsym' or `dlvsym' is set to RTLD_NEXT
the run-time address of the symbol called NAME in the next shared
object is returned.  The "next" relation is defined by the order
the shared objects were loaded.  */
# define RTLD_NEXT        ((void *) -1l)
/* If the first argument to `dlsym' or `dlvsym' is set to RTLD_DEFAULT
the run-time address of the symbol called NAME in the global scope
is returned.  */
# define RTLD_DEFAULT        ((void *) 0)
/* Type for namespace indeces.  */
typedef long int Lmid_t;
/* Special namespace ID values.  */
# define LM_ID_BASE        0        /* Initial namespace.  */
# define LM_ID_NEWLM        -1        /* For dlmopen: request new namespace.  */
#endif
__BEGIN_DECLS
/* Open the shared object FILE and map it in; return a handle that can be
passed to `dlsym' to get symbol values from it.  */
extern void *dlopen (const char *__file, int __mode) __THROWNL;
/* Unmap and close a shared object opened by `dlopen'.
The handle cannot be used again after calling `dlclose'.  */
extern int dlclose (void *__handle) __THROWNL __nonnull ((1));
/* Find the run-time address in the shared object HANDLE refers to
of the symbol called NAME.  */
extern void *dlsym (void *__restrict __handle,
const char *__restrict __name) __THROW __nonnull ((2));
#ifdef __USE_GNU
/* Like `dlopen', but request object to be allocated in a new namespace.  */
extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __THROWNL;
/* Find the run-time address in the shared object HANDLE refers to
of the symbol called NAME with VERSION.  */
extern void *dlvsym (void *__restrict __handle,
const char *__restrict __name,
const char *__restrict __version)
__THROW __nonnull ((2, 3));
#endif
/* When any of the above functions fails, call this function
to return a string describing the error.  Each call resets
the error string so that a following call returns null.  */
extern char *dlerror (void) __THROW;
#ifdef __USE_GNU
/* Structure containing information about object searched using
`dladdr'.  */
typedef struct
{
const char *dli_fname;        /* File name of defining object.  */
void *dli_fbase;                /* Load address of that object.  */
const char *dli_sname;        /* Name of nearest symbol.  */
void *dli_saddr;                /* Exact value of nearest symbol.  */
} Dl_info;
/* Fill in *INFO with the following information about ADDRESS.
Returns 0 iff no shared object's segments contain that address.  */
extern int dladdr (const void *__address, Dl_info *__info)
__THROW __nonnull ((2));
/* Same as `dladdr', but additionally sets *EXTRA_INFO according to FLAGS.  */
extern int dladdr1 (const void *__address, Dl_info *__info,
void **__extra_info, int __flags) __THROW __nonnull ((2));
/* These are the possible values for the FLAGS argument to `dladdr1'.
This indicates what extra information is stored at *EXTRA_INFO.
It may also be zero, in which case the EXTRA_INFO argument is not used.  */
enum
{
/* Matching symbol table entry (const ElfNN_Sym *).  */
RTLD_DL_SYMENT = 1,
/* The object containing the address (struct link_map *).  */
RTLD_DL_LINKMAP = 2
};
/* Get information about the shared object HANDLE refers to.
REQUEST is from among the values below, and determines the use of ARG.
On success, returns zero.  On failure, returns -1 and records an error
message to be fetched with `dlerror'.  */
extern int dlinfo (void *__restrict __handle,
int __request, void *__restrict __arg)
__THROW __nonnull ((1, 3));
/* These are the possible values for the REQUEST argument to `dlinfo'.  */
enum
{
/* Treat ARG as `lmid_t *'; store namespace ID for HANDLE there.  */
RTLD_DI_LMID = 1,
/* Treat ARG as `struct link_map **';
store the `struct link_map *' for HANDLE there.  */
RTLD_DI_LINKMAP = 2,
RTLD_DI_CONFIGADDR = 3,        /* Unsupported, defined by Solaris.  */
/* Treat ARG as `Dl_serinfo *' (see below), and fill in to describe the
directories that will be searched for dependencies of this object.
RTLD_DI_SERINFOSIZE fills in just the `dls_cnt' and `dls_size'
entries to indicate the size of the buffer that must be passed to
RTLD_DI_SERINFO to fill in the full information.  */
RTLD_DI_SERINFO = 4,
RTLD_DI_SERINFOSIZE = 5,
/* Treat ARG as `char *', and store there the directory name used to
expand $ORIGIN in this shared object's dependency file names.  */
RTLD_DI_ORIGIN = 6,
RTLD_DI_PROFILENAME = 7,        /* Unsupported, defined by Solaris.  */
RTLD_DI_PROFILEOUT = 8,        /* Unsupported, defined by Solaris.  */
/* Treat ARG as `size_t *', and store there the TLS module ID
of this object's PT_TLS segment, as used in TLS relocations;
store zero if this object does not define a PT_TLS segment.  */
RTLD_DI_TLS_MODID = 9,
/* Treat ARG as `void **', and store there a pointer to the calling
thread's TLS block corresponding to this object's PT_TLS segment.
Store a null pointer if this object does not define a PT_TLS
segment, or if the calling thread has not allocated a block for it.  */
RTLD_DI_TLS_DATA = 10,
RTLD_DI_MAX = 10
};
/* This is the type of elements in `Dl_serinfo', below.
The `dls_name' member points to space in the buffer passed to `dlinfo'.  */
typedef struct
{
char *dls_name;                /* Name of library search path directory.  */
unsigned int dls_flags;        /* Indicates where this directory came from. */
} Dl_serpath;
/* This is the structure that must be passed (by reference) to `dlinfo' for
the RTLD_DI_SERINFO and RTLD_DI_SERINFOSIZE requests.  */
typedef struct
{
size_t dls_size;                /* Size in bytes of the whole buffer.  */
unsigned int dls_cnt;                /* Number of elements in `dls_serpath'.  */
Dl_serpath dls_serpath[1];        /* Actually longer, dls_cnt elements.  */
} Dl_serinfo;
#endif /* __USE_GNU */
__END_DECLS
#endif        /* dlfcn.h */
-------------------------------------- 
----------------------------------------------------- 
<<CODE_h>>
[CODE_h](../fills/dlfcn_h/CODE_h)


[UP](###UP)
## H_CODE_c
:dlfcn.h:
[next](##H_CODE_m)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/dlfcn/dlfcn.c.html
#include <dlfcn.h>
int __dlfcn_argc attribute_hidden;
char **__dlfcn_argv attribute_hidden;
static void
init (int argc, char *argv[])
{
__dlfcn_argc = argc;
__dlfcn_argv = argv;
}
static void (*const init_array []) (int argc, char *argv[])
__attribute__ ((section (".init_array"), aligned (sizeof (void *))))
__attribute_used__ =
{
init
};
-------------------------------------- 
----------------------------------------------------- 
<<CODE_c>>
[CODE_c](../fills/dlfcn_h/CODE_c)


[UP](###UP)
## H_CODE_m
:dlfcn.h:
[next](##H_BOOKS)

<<CODE_m>>
[CODE_m](../fills/dlfcn_h/CODE_m)


[UP](###UP)
## H_BOOKS
:dlfcn.h:
[next](##H_BOOKS_ru)

<<BOOKS>>
[BOOKS](../fills/dlfcn_h/BOOKS)


[UP](###UP)
## H_BOOKS_ru
:dlfcn.h:
[next](##H_SUBSTANCES)

<<BOOKS_ru>>
[BOOKS_ru](../fills/dlfcn_h/BOOKS_ru)


[UP](###UP)
## H_SUBSTANCES
:dlfcn.h:
[UP](###UP)
p[dlclose](../utils/dlclose/dlclose.man)
p[dlerror](../utils/dlerror/dlerror.man)
p[dlopen](../utils/dlopen/dlopen.man)
p[dlsym](../utils/dlsym/dlsym.man)
s[link_map](../structs/link_map/link_map.man)
d[-ldl](../params/-ldl/-ldl.man)
