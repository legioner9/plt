## main using

    FILE *filed_2 = open_с(path_file_2, O_RDWR|O_CREAT, S_IRWXU, __FILE__, __LINE__);

## O_x constants

int open(const char *pathname, int flags, mode_t mode);

Получив в pathname имя файла, open() возвращает файловый дескриптор --- небольшое, неотрицательное значение --- для использования в последующих системных вызовах (read(2), write(2), lseek(2), fcntl(2) и т.д.). Файловый дескриптор, возвращаемый при успешном выполнении вызова, будет самым маленьким числом из файловых дескрипторов, которые ещё не открыты процессом.
По умолчанию, новый файловый дескриптор остаётся открытым при вызове execve(2) (т. е., флаг FD_CLOEXEC файлового дескриптора, описанный в fcntl(2), изначально сброшен; для изменения поведения по умолчанию можно использовать флаг O_CLOEXEC, он описан далее). Файловое смещение устанавливается на начало файла (см. lseek(2)).

Вызов open() создаёт новое открытое файловое описание — запись в системной таблице открытых файлов. В этой записи хранится смещение и флаги состояния файла (смотрите ниже). Файловый дескриптор — это ссылка на открытое файловое описание; с этой ссылкой ничего не происходит при последующем удалении pathname или переуказании имени на другой файл. Дополнительную информацию об открытых файловых описаниях смотрите в разделе ЗАМЕЧАНИЯ.

Параметр flags должен содержать один из следующих режимов доступа: O_RDONLY (только для чтения), O_WRONLY (только для записи) или O_RDWR (для чтения и записи).

Также в flags можно указывать флаги создания и состояния файла, объединяя их битовой операцией ИЛИ. Флаги создания файла: O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE и O_TRUNC. Флаги состояния файла — все оставшиеся, перечислены ниже. Различие между двумя этими группами в том, что флаги состояния можно запросить и (в некоторых случаях) изменить; смотрите fcntl(2).

Полный список флагов создания и флагов состояния файла:

O_APPEND
Файл открывается в режиме добавления. Перед каждым вызовом write(2) файловое смещение устанавливается в конец файла, как если бы это делалось с помощью lseek(2). Флаг O_APPEND может приводить к повреждению файлов в файловых системах NFS, если одновременно добавляют данные в файл несколько процессов. Это происходит из-за того, что NFS не поддерживает добавление в файл, поэтому клиентское ядро имитирует такое поведение, но при этом нельзя избежать состязательности процессов.
O_ASYNC
Включает ввод-вывод, управляемый сигналом: генерирует сигнал (по умолчанию SIGIO, но можно изменить с помощью fcntl(2)), когда становится возможным ввод или вывод для этого файлового дескриптора. Эта возможность доступна только для терминалов, псевдо-терминалов, сокетов, каналов (начиная с Linux 2.6) и FIFO. Подробней смотрите fcntl(2). Также смотрите ДЕФЕКТЫ далее.
O_CLOEXEC (начиная с Linux 2.6.23)
Устанавливает флаг close-on-exec на новом файловом дескрипторе. Указание данного флага позволяет программе избежать дополнительной операции fcntl(2) F_SETFD для установки флага FD_CLOEXEC.
Заметим, что использование этого флага обязательно для некоторых многонитиевых программ, так как использование отдельной операции fcntl(2) F_SETFD для установки флага FD_CLOEXEC недостаточно для избежания состязательности, когда одна нить открывает файловый дескриптор, а в тоже время другая нить может выполнять fork(2) и execve(2). В зависимости от порядка выполнения, состязательность может привести к тому, что файловый дескриптор, возвращённый open(), будет ненамеренно передан программе, выполняющейся в созданном с помощью fork(2) потомке (такого рода состязательность, в принципе, возможна для любых системных вызовов, создающих файловый дескриптор, у которого должен быть установлен флаг close-on-exec, и различные другие системные вызовы Linux предоставляют эквивалент флагу O_CLOEXEC, чтобы избежать этой проблемы).

O_CREAT
Если файл не существует, то он будет создан. Владелец (идентификатор пользователя) файла устанавливается в значение эффективного идентификатора пользователя процесса. Группа (идентификатор группы) устанавливается либо в значение эффективного идентификатора группы процесса, либо в значение идентификатора группы родительского каталога (зависит от типа файловой системы, параметров монтирования и режима родительского каталога; смотрите параметры монтирования bsdgroups и sysvgroups, описанные в mount(8)).

O_DIRECT (начиная с Linux 2.4.10)
Попытаться минимизировать влияние кэширования ввода-вывода при чтении и записи в файл. Обычно, это ухудшает производительность, но полезно для особых случаев, например, когда приложение выполняет кэширование самостоятельно. Файловый ввод-вывод выполняется непосредственно в/из буферов пространства пользователя. При флаге O_DIRECT предпринимаются все усилия для синхронной передачи данных, но это не гарантирует, как с флагом O_SYNC, передачу данных и необходимых метаданных. Чтобы гарантировать синхронный ввод-вывод вместе с O_DIRECT нужно использовать O_SYNC. Дальнейшее описание смотрите далее в разделе ЗАМЕЧАНИЯ.
Семантически похожий интерфейс (но устаревший) для блочных устройств описан в raw(8).

O_DIRECTORY
Если pathname не является каталогом, то завершить вызов с ошибкой. Этот флаг был добавлен в ядро версии 2.1.126, чтобы избежать проблем с «отказом в обслуживании», если opendir(3) был вызван для канала FIFO или ленточного устройства.
O_DSYNC
Операции записи файла будут выполнены согласно требованиям целостности синхронизации ввода-вывода data.
К времени возврата из write(2) (и подобных) выходные данные уже переданы в задействованное аппаратное обеспечение вместе со всеми метаданными файла, которые бы потребовались для получения данных (т. е., как если бы за каждым write(2) был выполнен вызов fdatasync(2)). Смотрите ЗАМЕЧАНИЯ далее.

O_EXCL
Гарантирует, что вызов создаст файл: если этот флаг указан вместе с O_CREAT и pathname уже существует, то open() завершится с ошибкой.
При использовании обоих флагов символьные ссылки не поддерживаются: если pathname является символьной ссылкой, то open() завершается с ошибкой независимо от того, куда указывает ссылка.

Вообще говоря, поведение с O_EXCL не определено, если этот флаг используется без O_CREAT. Есть одно исключение: в Linux 2.6 и более новых O_EXCL можно использовать без O_CREAT, если pathname указывает на блочное устройство. Если блочное устройство используется в системе (например, смонтировано), то open() завершится с ошибкой EBUSY.

Флаг O_EXCL поддерживается для NFS только, если используется NFSv3 или новее с ядром 2.6 или новее. В средах, где в NFS нет поддержки O_EXCL, программы, которые полагаются на это для выполнения задач блокировок, будут создавать состязательность процессов. Переносимым программам, которым нужно произвести атомарную блокировку файла с помощь файла блокировки, необходимо избегать зависимости от поддержки в NFS флага O_EXCL. В качестве решения можно создать уникальный файл в той же файловой системе (например, добавив имя узла и PID в название), чтобы создать ссылку на файл блокировки с помощью link(2). Если link(2) возвращает 0, то блокировка выполнена. В противном случае используйте stat(2), чтобы убедиться, что количество ссылок на уникальный файл возросло до двух. Это также означает, что блокировка была успешной.

O_LARGEFILE
(LFS) Позволяет открывать файлы, чей размер нельзя представить типом off_t (но можно представить типом off64_t). Для получения этого определения должен быть указан макрос _LARGEFILE64_SOURCE (до включения какого-либо заголовочного файла). Установка макроса тестирования возможностей _FILE_OFFSET_BITS в значение 64 (вместо использования O_LARGEFILE) является предпочтительным методом доступа к большим файлам на 32-битных системах (см. feature_test_macros(7)).
O_NOATIME (начиная с Linux 2.6.8)
Не обновлять время последнего доступа к файлу (st_atime в inode) при его чтении read(2). Этот флаг предназначен для использования в программах индексирования и резервного копирования; он позволяет значительно сократить количество обращений к диску. Флаг может быть не эффективен на некоторых файловых системах. Например, на NFS, где запись времени доступа выполняется сервером.
O_NOCTTY
Если pathname указывает на терминальное устройство (см. tty(4)), то оно не станет управляющим терминалом процесса, даже если процесс такового не имеет.
O_NOFOLLOW
Если pathname является символьной ссылкой, то открытие завершится неудачно. Это расширение FreeBSD, которое было добавлено в Linux версии 2.1.126. Все прочие символьные ссылки в имени будут обработаны как обычно. Также смотрите описание O_PATH далее.
O_NONBLOCK или O_NDELAY
Если возможно, файл открывается в неблокирующем режиме. Ни open(), ни другие последующие операции над возвращаемым дескриптором файла не заставят вызывающий процесс ждать.
Обратите внимание, что этот флаг не оказывает влияния на обычные файлы и блочные устройства, то есть операции ввода-вывода будут блокироваться на короткое время, если будет запрошено активность устройства, вне зависимости от установки флага O_NONBLOCK. Семантика O_NONBLOCK может быть когда-нибудь реализована, поэтому приложения не должны зависеть от блокировок при указании данного флага для обычных файлов и блочных устройств.

Для работы с каналами FIFO также смотрите fifo(7). Обсуждение влияния O_NONBLOCK в сочетании с обязательной файловой блокировкой или арендой (lease) смотрите в fcntl(2).

O_PATH (начиная с Linux 2.6.39)
Получить файловый дескриптор, который можно использовать для двух целей: для указания положения в дереве файловой системы и для выполнения операций, работающих исключительно на уровне файловых дескрипторов. Сам файл не открывается и другие файловые операции (например, read(2), write(2), fchmod(2), fchown(2), fgetxattr(2), mmap(2)) завершатся с ошибкой EBADF.
Следующие операции могут выполняться над полученным файловым дескриптором:

*
close(2); fchdir(2) (начиная с Linux 3.5); fstat(2) (начиная с Linux 3.6).
*
Создание дубликата файлового дескриптора (dup(2), fcntl(2) F_DUPFD и т.д.).
*
Получение и установка флагов файловых дескрипторов (fcntl(2) F_GETFD и F_SETFD).
*
Получение флагов состояния открытого файла с помощью операции fcntl(2) F_GETFL: в возвращаемые флаги будет включён бит O_PATH.
*
Передача файлового дескриптора в аргументе dirfd для openat(2) и других системных вызовов «*at()». К ним относится linkat(2) с флагом AT_EMPTY_PATH (или через procfs с помощью AT_SYMLINK_FOLLOW) даже, если файл не является каталогом.
*
Передача файлового дескриптора в другой процесс через доменный сокет UNIX (смотрите SCM_RIGHTS в unix(7)).
Если O_PATH указан в flags, то биты флагов, отличные от O_CLOEXEC, O_DIRECTORYи O_NOFOLLOW, игнорируются.
Если pathname является символьной ссылкой и также указан флаг O_NOFOLLOW, то вызов возвращает файловый дескриптор, указывающий на символьную ссылку. Этот файловый дескриптор можно использовать в аргументе dirfd для вызовов fchownat(2), fstatat(2), linkat(2) и readlinkat(2) с пустым именем пути, чтобы выполнить операцию над символьной ссылкой.

O_SYNC
Операции записи файла будут выполнены согласно требованиям целостности синхронизации ввода-вывода file (по сравнению с целостностью синхронизации ввода-вывода data, предоставляемой O_DSYNC).
К времени возврата из write(2) (и подобных) выходные данные и все метаданные файла уже переданы в задействованное аппаратное обеспечение (т. е., как если бы за каждым write(2) был выполнен вызов fsync(2)). Смотрите ЗАМЕЧАНИЯ далее.

O_TMPFILE (начиная с Linux 3.11)
Создание безымянного временного файла. В аргументе pathname указывается каталог; безымянная inode будет создана в файловой системе этого каталога. Всё записанное в полученный файл будет потеряно при закрытии последнего файлового дескриптора, если файлу не будет назначено имя.
Флаг O_TMPFILE должен быть указан вместе с O_RDWR или O_WRONLY и, необязательно, O_EXCL. Если O_EXCL не указан, то можно использовать linkat(2) для ссылки на временный файл в файловой системе, сделав его постоянным с помощью кода:

    char path[PATH_MAX];
    fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                            S_IRUSR | S_IWUSR);
    /* Файловый ввод-вывод в «fd»… */
    snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
    linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                            AT_SYMLINK_FOLLOW);
В этом случае аргументом mode у open() определяется режим доступа к файлу как с O_CREAT.

Указание O_EXCL вместе с O_TMPFILE отключает возможность создания символьной ссылки в файловой системе указанным ранее способом (заметим, что назначение O_EXCL в этом случае отличается от обычного O_EXCL).

Есть два основных случая использования O_TMPFILE:

*
Дополнительное свойство tmpfile(3): свободное от состязательности создание временных файлов, которые: автоматически удаляются при закрытии; недоступны по имени; не подвержены атаке через символьные ссылки; не требуют от вызывающего подбирать уникальное имя.
*
Создание файла, который изначально не видим, и который затем заполняется данными и позволяет изменять атрибуты в файловой системе (chown(2), chmod(2), fsetxattr(2) и т. д.) до автоматического встраивания в файловую систему в полностью законченном виде (с помощью linkat(2) как описано ранее).
Для O_TMPFILE требуется поддержка в файловой системе; она есть только в нескольких файловых системах Linux. В первой реализации поддержка предоставлялась в файловых системах ext2, ext3, ext4, UDF, Minix и shmem. Поддержка в XFS добавлена в Linux 3.15.
O_TRUNC
Если файл уже существует и является обычным файлом и режим доступа позволяет писать в этот файл (т.е. установлен флаг O_RDWR или O_WRONLY), то его длина будет урезана до нуля. Если файл является FIFO или терминальным устройством, то этот флаг игнорируется. В других случаях действие флага O_TRUNC не определено.


## S_x constants

int open(const char *pathname, int flags, mode_t mode);

В аргументе mode указывается режим использования, который используется при создании нового файла. Этот параметр должен указываться, если в flags устанавливается O_CREAT или O_TMPFILE; если O_CREAT или O_TMPFILE не указаны, то mode игнорируется. Эффективный режим изменяется согласно umask процесса как обычно: в случае отсутствия списков доступа по умолчанию режим созданного файла будет установлен согласно (mode & ~umask). Заметим, что этот режим будет учтён только при последующих обращениях к созданному файлу; вызов open(), создающий файл только для чтения, может вернуть файловый дескриптор доступный на чтение и запись.

Символьные константы, используемые в mode:

S_IRWXU
00700 пользователь (владелец файла) имеет права на чтение, запись и выполнение файла
S_IRUSR
00400 пользователь имеет права на чтение файла
S_IWUSR
00200 пользователь имеет права на запись в файл
S_IXUSR
00100 пользователь имеет права на выполнение файла
S_IRWXG
00070 группа имеет права на чтение, запись и выполнение файла
S_IRGRP
00040 группа имеет права на чтение файла
S_IWGRP
00020 группа имеет права на запись в файл
S_IXGRP
00010 группа имеет права на выполнение файла
S_IRWXO
00007 все остальные имеют права на чтение, запись и выполнение файла
S_IROTH
00004 все остальные имеют права на чтение файла
S_IWOTH
00002 все остальные имеют права на запись в файл
S_IXOTH
00001 все остальные имеют права на выполнение файла
Согласно POSIX, в случае, если в mode указаны другие биты, их воздействие не определено. В Linux для mode также доступны следующие биты:
S_ISUID
0004000 бит set-user-ID
S_ISGID
0002000 бит set-group-ID bit (см. stat(2))
S_ISVTX
0001000 закрепляющий бит (см. stat(2))