### UP
[fcntl.h](##fcntl.h)
[MAIN](##MAIN)
[MAIN_ru](##MAIN_ru)
[ANCORS](##ANCORS)
[ISU](##ISU)
[inet](##A_inet)
[inet](##books_inet)
[inet](##examples_inet)
[inet](##classic_inet)
[inet](##enters_inet)
[inet](##issue_code_inet)
[H_FILE](##H_FILE)
[H_SYNOPSIS](##H_SYNOPSIS)
[H_BUGS](##H_BUGS)
[H_DESCRIPTION_ru](##H_DESCRIPTION_ru)
[H_DESCRIPTION](##H_DESCRIPTION)
[H_ERRORS](##H_ERRORS)
[H_MIRRORS](##H_MIRRORS)
[H_EXAMPLES](##H_EXAMPLES)
[H_CODE_h](##H_CODE_h)
[H_CODE_c](##H_CODE_c)
[H_CODE_m](##H_CODE_m)
[H_BOOKS](##H_BOOKS)
[H_BOOKS_ru](##H_BOOKS_ru)
[H_SUBSTANCES](##H_SUBSTANCES)

[cat_hfiles](../cat_hfiles.md)
[cat_utils](../cat_utils.md)
[cat_structs](../cat_structs.md)
[cat_param](../cat_params.md)
[cat_macros](../cat_macross.md)
[cat_const](../cat_consts.md)
[cat_type](../cat_types.md)
[cat_any](../cat_anys.md)

[UP](###UP)
## MAIN
:fcntl.h:
[next](##MAIN_ru)

<<MAIN>>
[MAIN](../fills/fcntl_h/MAIN)


[UP](###UP)
## MAIN_ru
:fcntl.h:
[next](##ANCORS)

<<MAIN_ru>>
[MAIN_ru](../fills/fcntl_h/MAIN_ru)


[UP](###UP)
## ANCORS
:fcntl.h:
[next](##ISU)

<<ANCORS>>
[ANCORS](../fills/fcntl_h/ANCORS)


[UP](###UP)
## ISU
:fcntl.h:
[next](##H_FILE)

<<ISU>>
only read
:fcntl.h:
[ISU](../contents)
[next](##inet)


[UP](###UP)
## inet
:fcntl.h:
[next](##H_FILE)

[UP](###UP)
## A_inet
[manpages.org](https://www.google.ru/search?q=fcntl.h+site%3Ahttps%3A%2F%2Fmanpages.org)
[reposcope.com_ru](https://www.google.ru/search?q=fcntl.h+site%3Ahttps%3A%2F%2Freposcope.com%2Fmanpages%2Fru)
[pubs.opengroup.org](https://www.google.com/search?q=fcntl.h+https%3A%2F%2Fpubs.opengroup.org)
[manpages.debian.org](https://yandex.ru/search/?text=fcntl.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[www.opennet.ru](http://www.opennet.ru/man.shtml?category=2&topic=fcntl.h)
[man7.org](https://www.google.ru/search?q=fcntl.h+site%3Ahttps%3A%2F%2Fman7.org%2Flinux%2Fman-pages)
[en.cppreference.com](https://www.google.com/search?q=fcntl.h+en.cppreference.com)
[www.mankier.com](https://www.mankier.com/?q=fcntl.h)
[www.codecogs.com](https://www.google.ru/search?q=fcntl.h+https%3A%2F%2Fwww.codecogs.com%2Flibrary%2Fcomputing%2F)
[digitalmars.com](https://www.google.ru/search?q=fcntl.h+https%3A%2F%2Fdigitalmars.com%2Frtl%2F)


[UP](###UP)
## books_inet
[cpp.com.ru](https://yandex.ru/search/?text=fcntl.h+site%3Ahttps%3A%2F%2Fcpp.com.ru)
[linuxhint.com](https://www.google.ru/search?q=fcntl.h+site%3Ahttps%3A%2F%2Flinuxhint.com)
[gnu.org](https://www.google.ru/search?q=fcntl.h+site%3Ahttps%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2Fmanual)

[UP](###UP)
## examples_inet
[yandex:examples](https://yandex.ru/search/?text=fcntl.h+example+in+c)
[docs.oracle.com](https://www.google.com/search?q=fcntl.h+https%3A%2F%2Fdocs.oracle.com)
[manpages.debian.org](https://yandex.ru/search/?text=fcntl.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[osr507doc.xinuos.com](https://www.google.com/search?q=fcntl.h+http%3A%2F%2Fosr507doc.xinuos.com%2Fen%2Fman)
[cpp.hotexamples.com](https://cpp.hotexamples.com/examples/-/-/fcntl.h/cpp-fcntl.h-function-examples.html)
[all-ht.ru](https://yandex.ru/search/?text=fcntl.h+site%3Ahttp%3A%2F%2Fall-ht.ru%2Finf%2Fprog%2Fc%2F)
[cppreference.com](https://yandex.ru/search/?text=fcntl.h+site%3Ahttps%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2F)

[UP](###UP)
## classic_inet
[bogatyrev_c_unix](https://www.google.com/search?q=fcntl.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fbogatyrev_c_unix)
[kr_cbook](https://www.google.com/search?q=fcntl.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fkr_cbook)

[UP](###UP)
## enters_inet
[pubs.opengroup.org](https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html)

[UP](###UP)
## issue_code_inet
[code.woboq.org](https://www.google.com/search?h=&sitesearch=https%3A%2F%2Fcode.woboq.org%2Fuserspace%2Fglibc%2F&q=fcntl.h)


[UP](###UP)
## H_FILE [fcntl_h.md](fcntl_h.md)
:fcntl.h:
[next](##H_SYNOPSIS)

[UP](###UP)
## H_SYNOPSIS
:fcntl.h:
[next](##H_DESCRIPTION_ru)

<<SYNOPSIS>>
[SYNOPSIS](../fills/fcntl_h/SYNOPSIS)


[UP](###UP)
## H_DESCRIPTION_ru
:fcntl.h:
[next](##H_DESCRIPTION)

<<DESCRIPTION_ru>>
[DESCRIPTION_ru](../fills/fcntl_h/DESCRIPTION_ru)


[UP](###UP)
## H_DESCRIPTION
:fcntl.h:
[next](##H_ERRORS)

<<DESCRIPTION>>
[DESCRIPTION](../fills/fcntl_h/DESCRIPTION)


[UP](###UP)
## H_ERRORS
:fcntl.h:
[next](##H_MIRRORS)

<<ERRORS>>
[ERRORS](../fills/fcntl_h/ERRORS)


[UP](###UP)
## H_MIRRORS
:fcntl.h:
[next](##H_BUGS)

<<MIRRORS>>
[MIRRORS](../fills/fcntl_h/MIRRORS)


[UP](###UP)
## H_BUGS
:fcntl.h:
[next](##H_EXAMPLES)

<<BUGS>>
[BUGS](../fills/fcntl_h/BUGS)


[UP](###UP)
## H_EXAMPLES
:fcntl.h:
[next](##H_CODE)

<<EXAMPLES>>
[EXAMPLES](../fills/fcntl_h/EXAMPLES)


[UP](###UP)
## H_CODE_h
:fcntl.h:
[next](##H_CODE_c)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/bits/fcntl.h.html
#ifndef        _FCNTL_H
#error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
#endif
/* File access modes for `open' and `fcntl'.  */
#define        O_RDONLY        0        /* Open read-only.  */
#define        O_WRONLY        1        /* Open write-only.  */
#define        O_RDWR                2        /* Open read/write.  */
/* Bits OR'd into the second argument to open.  */
#define        O_CREAT                0x0200        /* Create file if it doesn't exist.  */
#define        O_EXCL                0x0800        /* Fail if file already exists.  */
#define        O_TRUNC                0x0400        /* Truncate file to zero length.  */
#define        O_NOCTTY        0x8000        /* Don't assign a controlling terminal.  */
#define        O_ASYNC                0x0040        /* Send SIGIO to owner when data is ready.  */
#define        O_FSYNC                0x0080        /* Synchronous writes.  */
#define        O_SYNC                O_FSYNC
#ifdef        __USE_MISC
#define        O_SHLOCK        0x0010        /* Open with shared file lock.  */
#define        O_EXLOCK        0x0020        /* Open with shared exclusive lock.  */
#endif
#ifdef __USE_XOPEN2K8
# define O_DIRECTORY        0x00200000        /* Must be a directory.         */
# define O_NOFOLLOW        0x00000100        /* Do not follow links.         */
# define O_CLOEXEC        0x00400000      /* Set close_on_exec.  */
#endif
#if defined __USE_POSIX199309 || defined __USE_UNIX98
# define O_DSYNC        0x00010000        /* Synchronize data.  */
# define O_RSYNC        0x00020000        /* Synchronize read operations.         */
#endif
/* All opens support large file sizes, so there is no flag bit for this.  */
#ifdef __USE_LARGEFILE64
# define O_LARGEFILE        0
#endif
/* File status flags for `open' and `fcntl'.  */
#define        O_APPEND        0x0008        /* Writes append to the file.  */
#define        O_NONBLOCK        0x0004        /* Non-blocking I/O.  */
#ifdef __USE_MISC
# define O_NDELAY        O_NONBLOCK
#endif
#ifdef __USE_MISC
/* Flags for TIOCFLUSH.  */
# define FREAD                1
# define FWRITE                2
/* Traditional BSD names the O_* bits.  */
# define FASYNC                O_ASYNC
# define FFSYNC                O_FSYNC
# define FSYNC                O_SYNC
# define FAPPEND        O_APPEND
# define FNDELAY        O_NDELAY
#endif
/* Mask for file access modes.  This is system-dependent in case
some system ever wants to define some other flavor of access.  */
#define        O_ACCMODE        (O_RDONLY|O_WRONLY|O_RDWR)
/* Values for the second argument to `fcntl'.  */
#define        F_DUPFD                  0        /* Duplicate file descriptor.  */
#define        F_GETFD                1        /* Get file descriptor flags.  */
#define        F_SETFD                2        /* Set file descriptor flags.  */
#define        F_GETFL                3        /* Get file status flags.  */
#define        F_SETFL                4        /* Set file status flags.  */
#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
#define        F_GETOWN        5        /* Get owner (receiver of SIGIO).  */
#define        F_SETOWN        6        /* Set owner (receiver of SIGIO).  */
#endif
#define        F_GETLK                7        /* Get record locking info.  */
#define        F_SETLK                8        /* Set record locking info (non-blocking).  */
#define        F_SETLKW        9        /* Set record locking info (blocking).  */
/* Not necessary, we always have 64-bit offsets.  */
#define F_GETLK64        F_GETLK        /* Get record locking info.  */
#define F_SETLK64        F_SETLK        /* Set record locking info (non-blocking).  */
#define F_SETLKW64        F_SETLKW/* Set record locking info (blocking).        */
#ifdef __USE_XOPEN2K8
# define F_DUPFD_CLOEXEC 12        /* Duplicate file descriptor with
close-on-exit set.  */
#endif
/* File descriptor flags used with F_GETFD and F_SETFD.  */
#define        FD_CLOEXEC        1        /* Close on exec.  */
#include <bits/types.h>
/* The structure describing an advisory lock.  This is the type of the third
argument to `fcntl' for the F_GETLK, F_SETLK, and F_SETLKW requests.  */
struct flock
{
__off_t l_start;        /* Offset where the lock begins.  */
__off_t l_len;        /* Size of the locked area; zero means until EOF.  */
__pid_t l_pid;        /* Process holding the lock.  */
short int l_type;        /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
short int l_whence;        /* Where `l_start' is relative to (like `lseek').  */
};
#ifdef __USE_LARGEFILE64
/* Note this matches struct flock exactly.  */
struct flock64
{
__off_t l_start;        /* Offset where the lock begins.  */
__off_t l_len;        /* Size of the locked area; zero means until EOF.  */
__pid_t l_pid;        /* Process holding the lock.  */
short int l_type;        /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
short int l_whence;        /* Where `l_start' is relative to (like `lseek').  */
};
#endif
/* Values for the `l_type' field of a `struct flock'.  */
#define        F_RDLCK        1        /* Read lock.  */
#define        F_WRLCK        2        /* Write lock.  */
#define        F_UNLCK        3        /* Remove lock.  */
/* Advise to `posix_fadvise'.  */
#ifdef __USE_XOPEN2K
# define POSIX_FADV_NORMAL        0 /* No further special treatment.  */
# define POSIX_FADV_RANDOM        1 /* Expect random page references.  */
# define POSIX_FADV_SEQUENTIAL        2 /* Expect sequential page references.  */
# define POSIX_FADV_WILLNEED        3 /* Will need these pages.  */
# define POSIX_FADV_DONTNEED        4 /* Don't need these pages.  */
# define POSIX_FADV_NOREUSE        5 /* Data will be accessed once.  */
#endif
-------------------------------------- 
----------------------------------------------------- 
<<CODE_h>>
[CODE_h](../fills/fcntl_h/CODE_h)


[UP](###UP)
## H_CODE_c
:fcntl.h:
[next](##H_CODE_m)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/fcntl.c.html
#include <fcntl.h>
#include <stdarg.h>
#include <errno.h>
#include <sysdep-cancel.h>
#ifndef __OFF_T_MATCHES_OFF64_T
# ifndef FCNTL_ADJUST_CMD
#  define FCNTL_ADJUST_CMD(__cmd) __cmd
# endif
int
__libc_fcntl (int fd, int cmd, ...)
{
va_list ap;
void *arg;
va_start (ap, cmd);
arg = va_arg (ap, void *);
va_end (ap);
cmd = FCNTL_ADJUST_CMD (cmd);
switch (cmd)
{
case F_SETLKW:
case F_SETLKW64:
return SYSCALL_CANCEL (fcntl64, fd, cmd, arg);
case F_OFD_SETLKW:
{
struct flock *flk = (struct flock *) arg;
struct flock64 flk64 =
{
.l_type = flk->l_type,
.l_whence = flk->l_whence,
.l_start = flk->l_start,
.l_len = flk->l_len,
.l_pid = flk->l_pid
};
return SYSCALL_CANCEL (fcntl64, fd, cmd, &flk64);
}
case F_OFD_GETLK:
case F_OFD_SETLK:
{
struct flock *flk = (struct flock *) arg;
struct flock64 flk64 =
{
.l_type = flk->l_type,
.l_whence = flk->l_whence,
.l_start = flk->l_start,
.l_len = flk->l_len,
.l_pid = flk->l_pid
};
int ret = INLINE_SYSCALL_CALL (fcntl64, fd, cmd, &flk64);
if (ret == -1)
return -1;
if ((off_t) flk64.l_start != flk64.l_start
|| (off_t) flk64.l_len != flk64.l_len)
{
__set_errno (EOVERFLOW);
return -1;
}
flk->l_type = flk64.l_type;
flk->l_whence = flk64.l_whence;
flk->l_start = flk64.l_start;
flk->l_len = flk64.l_len;
flk->l_pid = flk64.l_pid;
return ret;
}
/* Since only F_SETLKW{64}/F_OLD_SETLK are cancellation entrypoints and
only OFD locks require LFS handling, all others flags are handled
unmodified by calling __NR_fcntl64.  */
default:
return __fcntl64_nocancel_adjusted (fd, cmd, arg);
}
}
libc_hidden_def (__libc_fcntl)
weak_alias (__libc_fcntl, __fcntl)
libc_hidden_weak (__fcntl)
# include <shlib-compat.h>
# if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_28)
int
__old_libc_fcntl64 (int fd, int cmd, ...)
{
va_list ap;
void *arg;
va_start (ap, cmd);
arg = va_arg (ap, void *);
va_end (ap);
/* Previous versions called __NR_fcntl64 for fcntl (which did not handle
OFD locks in LFS mode).  */
return __libc_fcntl64 (fd, cmd, arg);
}
compat_symbol (libc, __old_libc_fcntl64, fcntl, GLIBC_2_0);
versioned_symbol (libc, __libc_fcntl, fcntl, GLIBC_2_28);
# else
weak_alias (__libc_fcntl, fcntl)
# endif
#endif /* __OFF_T_MATCHES_OFF64_T  */
-------------------------------------- 
----------------------------------------------------- 
<<CODE_c>>
[CODE_c](../fills/fcntl_h/CODE_c)


[UP](###UP)
## H_CODE_m
:fcntl.h:
[next](##H_BOOKS)

<<CODE_m>>
[CODE_m](../fills/fcntl_h/CODE_m)


[UP](###UP)
## H_BOOKS
:fcntl.h:
[next](##H_BOOKS_ru)

<<BOOKS>>
[BOOKS](../fills/fcntl_h/BOOKS)


[UP](###UP)
## H_BOOKS_ru
:fcntl.h:
[next](##H_SUBSTANCES)

<<BOOKS_ru>>
[BOOKS_ru](../fills/fcntl_h/BOOKS_ru)


[UP](###UP)
## H_SUBSTANCES
:fcntl.h:
[UP](###UP)
p[creat](../utils/creat/creat.man)
p[fcntl](../utils/fcntl/fcntl.man)
p[open](../utils/open/open.man)
p[openat](../utils/openat/openat.man)
p[posix_fadvise](../utils/posix_fadvise/posix_fadvise.man)
p[posix_fallocate](../utils/posix_fallocate/posix_fallocate.man)
s[flock](../structs/flock/flock.man)
s[f_owner_ex](../structs/f_owner_ex/f_owner_ex.man)
c[F_DUPFD](../consts/F_DUPFD/F_DUPFD.man)
c[F_DUPFD_CLOEXEC](../consts/F_DUPFD_CLOEXEC/F_DUPFD_CLOEXEC.man)
c[F_GETFD](../consts/F_GETFD/F_GETFD.man)
c[F_SETFD](../consts/F_SETFD/F_SETFD.man)
c[F_GETFL](../consts/F_GETFL/F_GETFL.man)
c[F_SETFL](../consts/F_SETFL/F_SETFL.man)
c[F_SETLK](../consts/F_SETLK/F_SETLK.man)
c[F_SETLKW](../consts/F_SETLKW/F_SETLKW.man)
c[F_GETLK](../consts/F_GETLK/F_GETLK.man)
c[F_OFD_SETLK](../consts/F_OFD_SETLK/F_OFD_SETLK.man)
c[F_OFD_SETLKW](../consts/F_OFD_SETLKW/F_OFD_SETLKW.man)
c[F_OFD_GETLK](../consts/F_OFD_GETLK/F_OFD_GETLK.man)
c[F_GETOWN](../consts/F_GETOWN/F_GETOWN.man)
c[F_SETOWN](../consts/F_SETOWN/F_SETOWN.man)
c[F_GETOWN_EX](../consts/F_GETOWN_EX/F_GETOWN_EX.man)
c[F_SETOWN_EX](../consts/F_SETOWN_EX/F_SETOWN_EX.man)
c[F_OWNER_TID](../consts/F_OWNER_TID/F_OWNER_TID.man)
c[F_OWNER_PID](../consts/F_OWNER_PID/F_OWNER_PID.man)
c[F_OWNER_PGRP](../consts/F_OWNER_PGRP/F_OWNER_PGRP.man)
c[F_GETSIG](../consts/F_GETSIG/F_GETSIG.man)
c[F_SETSIG](../consts/F_SETSIG/F_SETSIG.man)
c[F_SETLEASE](../consts/F_SETLEASE/F_SETLEASE.man)
c[F_RDLCK](../consts/F_RDLCK/F_RDLCK.man)
c[F_WRLCK](../consts/F_WRLCK/F_WRLCK.man)
c[F_UNLCK](../consts/F_UNLCK/F_UNLCK.man)
c[F_GETLEASE](../consts/F_GETLEASE/F_GETLEASE.man)
c[F_NOTIFY](../consts/F_NOTIFY/F_NOTIFY.man)
c[DN_ACCESS](../consts/DN_ACCESS/DN_ACCESS.man)
c[DN_MODIFY](../consts/DN_MODIFY/DN_MODIFY.man)
c[DN_CREATE](../consts/DN_CREATE/DN_CREATE.man)
c[DN_DELETE](../consts/DN_DELETE/DN_DELETE.man)
c[DN_RENAME](../consts/DN_RENAME/DN_RENAME.man)
c[DN_ATTRIB](../consts/DN_ATTRIB/DN_ATTRIB.man)
c[DN_MULTISHOT](../consts/DN_MULTISHOT/DN_MULTISHOT.man)
c[F_SETPIPE_SZ](../consts/F_SETPIPE_SZ/F_SETPIPE_SZ.man)
c[F_GETPIPE_SZ](../consts/F_GETPIPE_SZ/F_GETPIPE_SZ.man)
c[F_ADD_SEALS](../consts/F_ADD_SEALS/F_ADD_SEALS.man)
c[F_GET_SEALS](../consts/F_GET_SEALS/F_GET_SEALS.man)
c[F_SEAL_SEAL](../consts/F_SEAL_SEAL/F_SEAL_SEAL.man)
c[F_SEAL_SHRINK](../consts/F_SEAL_SHRINK/F_SEAL_SHRINK.man)
c[F_SEAL_GROW](../consts/F_SEAL_GROW/F_SEAL_GROW.man)
c[F_SEAL_WRITE](../consts/F_SEAL_WRITE/F_SEAL_WRITE.man)
