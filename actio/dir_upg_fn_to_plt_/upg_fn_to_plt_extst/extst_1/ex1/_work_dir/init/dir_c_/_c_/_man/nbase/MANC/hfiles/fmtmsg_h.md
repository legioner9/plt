### UP
[fmtmsg.h](##fmtmsg.h)
[MAIN](##MAIN)
[MAIN_ru](##MAIN_ru)
[ANCORS](##ANCORS)
[ISU](##ISU)
[inet](##A_inet)
[inet](##books_inet)
[inet](##examples_inet)
[inet](##classic_inet)
[inet](##enters_inet)
[inet](##issue_code_inet)
[H_FILE](##H_FILE)
[H_SYNOPSIS](##H_SYNOPSIS)
[H_BUGS](##H_BUGS)
[H_DESCRIPTION_ru](##H_DESCRIPTION_ru)
[H_DESCRIPTION](##H_DESCRIPTION)
[H_ERRORS](##H_ERRORS)
[H_MIRRORS](##H_MIRRORS)
[H_EXAMPLES](##H_EXAMPLES)
[H_CODE_h](##H_CODE_h)
[H_CODE_c](##H_CODE_c)
[H_CODE_m](##H_CODE_m)
[H_BOOKS](##H_BOOKS)
[H_BOOKS_ru](##H_BOOKS_ru)
[H_SUBSTANCES](##H_SUBSTANCES)

[cat_hfiles](../cat_hfiles.md)
[cat_utils](../cat_utils.md)
[cat_structs](../cat_structs.md)
[cat_param](../cat_params.md)
[cat_macros](../cat_macross.md)
[cat_const](../cat_consts.md)
[cat_type](../cat_types.md)
[cat_any](../cat_anys.md)

[UP](###UP)
## MAIN
:fmtmsg.h:
[next](##MAIN_ru)

<<MAIN>>
[MAIN](../fills/fmtmsg_h/MAIN)


[UP](###UP)
## MAIN_ru
:fmtmsg.h:
[next](##ANCORS)

<<MAIN_ru>>
[MAIN_ru](../fills/fmtmsg_h/MAIN_ru)


[UP](###UP)
## ANCORS
:fmtmsg.h:
[next](##ISU)

<<ANCORS>>
[ANCORS](../fills/fmtmsg_h/ANCORS)


[UP](###UP)
## ISU
:fmtmsg.h:
[next](##H_FILE)

<<ISU>>
only read
:fmtmsg.h:
[ISU](../contents)
[next](##inet)


[UP](###UP)
## inet
:fmtmsg.h:
[next](##H_FILE)

[UP](###UP)
## A_inet
[manpages.org](https://www.google.ru/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Fmanpages.org)
[reposcope.com_ru](https://www.google.ru/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Freposcope.com%2Fmanpages%2Fru)
[pubs.opengroup.org](https://www.google.com/search?q=fmtmsg.h+https%3A%2F%2Fpubs.opengroup.org)
[manpages.debian.org](https://yandex.ru/search/?text=fmtmsg.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[www.opennet.ru](http://www.opennet.ru/man.shtml?category=2&topic=fmtmsg.h)
[man7.org](https://www.google.ru/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Fman7.org%2Flinux%2Fman-pages)
[en.cppreference.com](https://www.google.com/search?q=fmtmsg.h+en.cppreference.com)
[www.mankier.com](https://www.mankier.com/?q=fmtmsg.h)
[www.codecogs.com](https://www.google.ru/search?q=fmtmsg.h+https%3A%2F%2Fwww.codecogs.com%2Flibrary%2Fcomputing%2F)
[digitalmars.com](https://www.google.ru/search?q=fmtmsg.h+https%3A%2F%2Fdigitalmars.com%2Frtl%2F)


[UP](###UP)
## books_inet
[cpp.com.ru](https://yandex.ru/search/?text=fmtmsg.h+site%3Ahttps%3A%2F%2Fcpp.com.ru)
[linuxhint.com](https://www.google.ru/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Flinuxhint.com)
[gnu.org](https://www.google.ru/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2Fmanual)

[UP](###UP)
## examples_inet
[yandex:examples](https://yandex.ru/search/?text=fmtmsg.h+example+in+c)
[docs.oracle.com](https://www.google.com/search?q=fmtmsg.h+https%3A%2F%2Fdocs.oracle.com)
[manpages.debian.org](https://yandex.ru/search/?text=fmtmsg.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[osr507doc.xinuos.com](https://www.google.com/search?q=fmtmsg.h+http%3A%2F%2Fosr507doc.xinuos.com%2Fen%2Fman)
[cpp.hotexamples.com](https://cpp.hotexamples.com/examples/-/-/fmtmsg.h/cpp-fmtmsg.h-function-examples.html)
[all-ht.ru](https://yandex.ru/search/?text=fmtmsg.h+site%3Ahttp%3A%2F%2Fall-ht.ru%2Finf%2Fprog%2Fc%2F)
[cppreference.com](https://yandex.ru/search/?text=fmtmsg.h+site%3Ahttps%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2F)

[UP](###UP)
## classic_inet
[bogatyrev_c_unix](https://www.google.com/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fbogatyrev_c_unix)
[kr_cbook](https://www.google.com/search?q=fmtmsg.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fkr_cbook)

[UP](###UP)
## enters_inet
[pubs.opengroup.org](https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html)

[UP](###UP)
## issue_code_inet
[code.woboq.org](https://www.google.com/search?h=&sitesearch=https%3A%2F%2Fcode.woboq.org%2Fuserspace%2Fglibc%2F&q=fmtmsg.h)


[UP](###UP)
## H_FILE [fmtmsg_h.md](fmtmsg_h.md)
:fmtmsg.h:
[next](##H_SYNOPSIS)

[UP](###UP)
## H_SYNOPSIS
:fmtmsg.h:
[next](##H_DESCRIPTION_ru)

<<SYNOPSIS>>
[SYNOPSIS](../fills/fmtmsg_h/SYNOPSIS)


[UP](###UP)
## H_DESCRIPTION_ru
:fmtmsg.h:
[next](##H_DESCRIPTION)

<<DESCRIPTION_ru>>
[DESCRIPTION_ru](../fills/fmtmsg_h/DESCRIPTION_ru)


[UP](###UP)
## H_DESCRIPTION
:fmtmsg.h:
[next](##H_ERRORS)

<<DESCRIPTION>>
[DESCRIPTION](../fills/fmtmsg_h/DESCRIPTION)


[UP](###UP)
## H_ERRORS
:fmtmsg.h:
[next](##H_MIRRORS)

<<ERRORS>>
[ERRORS](../fills/fmtmsg_h/ERRORS)


[UP](###UP)
## H_MIRRORS
:fmtmsg.h:
[next](##H_BUGS)

<<MIRRORS>>
[MIRRORS](../fills/fmtmsg_h/MIRRORS)


[UP](###UP)
## H_BUGS
:fmtmsg.h:
[next](##H_EXAMPLES)

<<BUGS>>
[BUGS](../fills/fmtmsg_h/BUGS)


[UP](###UP)
## H_EXAMPLES
:fmtmsg.h:
[next](##H_CODE)

<<EXAMPLES>>
[EXAMPLES](../fills/fmtmsg_h/EXAMPLES)


[UP](###UP)
## H_CODE_h
:fmtmsg.h:
[next](##H_CODE_c)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/stdlib/fmtmsg.h.html
#ifndef __FMTMSG_H
#define __FMTMSG_H        1
#include <features.h>
__BEGIN_DECLS
/* Values to control `fmtmsg' function.  */
enum
{
MM_HARD = 0x001,        /* Source of the condition is hardware.  */
#define MM_HARD MM_HARD
MM_SOFT = 0x002,        /* Source of the condition is software.  */
#define MM_SOFT MM_SOFT
MM_FIRM = 0x004,        /* Source of the condition is firmware.  */
#define MM_FIRM MM_FIRM
MM_APPL = 0x008,        /* Condition detected by application.  */
#define MM_APPL MM_APPL
MM_UTIL = 0x010,        /* Condition detected by utility.  */
#define MM_UTIL MM_UTIL
MM_OPSYS = 0x020,        /* Condition detected by operating system.  */
#define MM_OPSYS MM_OPSYS
MM_RECOVER = 0x040,        /* Recoverable error.  */
#define MM_RECOVER MM_RECOVER
MM_NRECOV = 0x080,        /* Non-recoverable error.  */
#define MM_NRECOV MM_NRECOV
MM_PRINT = 0x100,        /* Display message in standard error.  */
#define MM_PRINT MM_PRINT
MM_CONSOLE = 0x200        /* Display message on system console.  */
#define MM_CONSOLE MM_CONSOLE
};
/* Values to be for SEVERITY parameter of `fmtmsg'.  */
enum
{
MM_NOSEV = 0,                /* No severity level provided for the message.  */
#define MM_NOSEV MM_NOSEV
MM_HALT,                /* Error causing application to halt.  */
#define MM_HALT MM_HALT
MM_ERROR,                /* Application has encountered a non-fatal fault.  */
#define MM_ERROR MM_ERROR
MM_WARNING,                /* Application has detected unusual non-error
condition.  */
#define MM_WARNING MM_WARNING
MM_INFO                /* Informative message.  */
#define MM_INFO MM_INFO
};
/* Macros which can be used as null values for the arguments of `fmtmsg'.  */
#define MM_NULLLBL        ((char *) 0)
#define MM_NULLSEV        0
#define MM_NULLMC        ((long int) 0)
#define MM_NULLTXT        ((char *) 0)
#define MM_NULLACT        ((char *) 0)
#define MM_NULLTAG        ((char *) 0)
/* Possible return values of `fmtmsg'.  */
enum
{
MM_NOTOK = -1,
#define MM_NOTOK MM_NOTOK
MM_OK = 0,
#define MM_OK MM_OK
MM_NOMSG = 1,
#define MM_NOMSG MM_NOMSG
MM_NOCON = 4
#define MM_NOCON MM_NOCON
};
/* Print message with given CLASSIFICATION, LABEL, SEVERITY, TEXT, ACTION
and TAG to console or standard error.  */
extern int fmtmsg (long int __classification, const char *__label,
int __severity, const char *__text,
const char *__action, const char *__tag);
#ifdef __USE_MISC
/* Add or remove severity level.  */
extern int addseverity (int __severity, const char *__string) __THROW;
#endif
__END_DECLS
#endif /* fmtmsg.h */
-------------------------------------- 
----------------------------------------------------- 
<<CODE_h>>
[CODE_h](../fills/fmtmsg_h/CODE_h)


[UP](###UP)
## H_CODE_c
:fmtmsg.h:
[next](##H_CODE_m)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/stdlib/fmtmsg.c.html
#include <fmtmsg.h>
#include <libc-lock.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syslog.h>
#include <wchar.h>
/* We have global data, protect the modification.  */
__libc_lock_define_initialized (static, lock)
enum
{
label_mask = 0x01,
severity_mask = 0x02,
text_mask = 0x04,
action_mask = 0x08,
tag_mask = 0x10,
all_mask = label_mask | severity_mask | text_mask | action_mask | tag_mask
};
static const struct
{
uint32_t len;
/* Adjust the size if new elements are added.  */
const char name[12];
} keywords[] =
{
{ 5, "label" },
{ 8, "severity" },
{ 4, "text" },
{ 6, "action"},
{ 3, "tag" }
};
#define NKEYWORDS (sizeof (keywords) / sizeof (keywords[0]))
struct severity_info
{
int severity;
const char *string;
struct severity_info *next;
};
/* List of known severities.  */
static const struct severity_info nosev =
{
MM_NOSEV, "", NULL
};
static const struct severity_info haltsev =
{
MM_HALT, "HALT", (struct severity_info *) &nosev
};
static const struct severity_info errorsev =
{
MM_ERROR, "ERROR", (struct severity_info *) &haltsev
};
static const struct severity_info warningsev =
{
MM_WARNING, "WARNING", (struct severity_info *) &errorsev
};
static const struct severity_info infosev =
{
MM_INFO, "INFO", (struct severity_info *) &warningsev
};
/* Start of the list.  */
static struct severity_info *severity_list = (struct severity_info *) &infosev;
/* Mask of values we will print.  */
static int print;
/* Prototypes for local functions.  */
static void init (void);
static int internal_addseverity (int severity, const char *string);
int
fmtmsg (long int classification, const char *label, int severity,
const char *text, const char *action, const char *tag)
{
__libc_once_define (static, once);
struct severity_info *severity_rec;
/* Make sure everything is initialized.  */
__libc_once (once, init);
/* Start the real work.  First check whether the input is ok.  */
if (label != MM_NULLLBL)
{
/* Must be two fields, separated by a colon.  */
const char *cp = strchr (label, ':');
if (cp == NULL)
return MM_NOTOK;
/* The first field must not contain more than 10 bytes.  */
if (cp - label > 10
/* The second field must not have more than 14 bytes.  */
|| strlen (cp + 1) > 14)
return MM_NOTOK;
}
#ifdef __libc_ptf_call
/* We do not want this call to be cut short by a thread
cancellation.  Therefore disable cancellation for now.  */
int state = PTHREAD_CANCEL_ENABLE;
__libc_ptf_call (__pthread_setcancelstate,
(PTHREAD_CANCEL_DISABLE, &state), 0);
#endif
__libc_lock_lock (lock);
for (severity_rec = severity_list; severity_rec != NULL;
severity_rec = severity_rec->next)
if (severity == severity_rec->severity)
/* Bingo.  */
break;
/* If we don't know anything about the severity level return an error.  */
int result = MM_NOTOK;
if (severity_rec != NULL)
{
result = MM_OK;
/* Now we can print.  */
if (classification & MM_PRINT)
{
int do_label = (print & label_mask) && label != MM_NULLLBL;
int do_severity = (print & severity_mask) && severity != MM_NULLSEV;
int do_text = (print & text_mask) && text != MM_NULLTXT;
int do_action = (print & action_mask) && action != MM_NULLACT;
int do_tag = (print & tag_mask) && tag != MM_NULLTAG;
int need_colon = (do_label
&& (do_severity | do_text | do_action | do_tag));
if (__fxprintf (stderr, "%s%s%s%s%s%s%s%s%s%s
",
do_label ? label : "",
need_colon ? ": " : "",
do_severity ? severity_rec->string : "",
do_severity && (do_text | do_action | do_tag)
? ": " : "",
do_text ? text : "",
do_text && (do_action | do_tag) ? "
" : "",
do_action ? "TO FIX: " : "",
do_action ? action : "",
do_action && do_tag ? "  " : "",
do_tag ? tag : "") < 0)
/* Oh, oh.  An error occurred during the output.  */
result = MM_NOMSG;
}
if (classification & MM_CONSOLE)
{
int do_label = label != MM_NULLLBL;
int do_severity = severity != MM_NULLSEV;
int do_text = text != MM_NULLTXT;
int do_action = action != MM_NULLACT;
int do_tag = tag != MM_NULLTAG;
int need_colon = (do_label
&& (do_severity | do_text | do_action | do_tag));
syslog (LOG_ERR, "%s%s%s%s%s%s%s%s%s%s
",
do_label ? label : "",
need_colon ? ": " : "",
do_severity ? severity_rec->string : "",
do_severity && (do_text | do_action | do_tag) ? ": " : "",
do_text ? text : "",
do_text && (do_action | do_tag) ? "
" : "",
do_action ? "TO FIX: " : "",
do_action ? action : "",
do_action && do_tag ? "  " : "",
do_tag ? tag : "");
}
}
__libc_lock_unlock (lock);
#ifdef __libc_ptf_call
__libc_ptf_call (__pthread_setcancelstate, (state, NULL), 0);
#endif
return result;
}
/* Initialize from environment variable content.  */
static void
init (void)
{
const char *msgverb_var = getenv ("MSGVERB");
const char *sevlevel_var = getenv ("SEV_LEVEL");
if (msgverb_var != NULL && msgverb_var[0] != '0')
{
/* Using this extra variable allows us to work without locking.  */
do
{
size_t cnt;
for (cnt = 0; cnt < NKEYWORDS; ++cnt)
if (memcmp (msgverb_var,
keywords[cnt].name, keywords[cnt].len) == 0
&& (msgverb_var[keywords[cnt].len] == ':'
|| msgverb_var[keywords[cnt].len] == '0'))
break;
if (cnt < NKEYWORDS)
{
print |= 1 << cnt;
msgverb_var += keywords[cnt].len;
if (msgverb_var[0] == ':')
++msgverb_var;
}
else
{
/* We found an illegal keyword in the environment
variable.  The specifications say that we print all
fields.  */
print = all_mask;
break;
}
}
while (msgverb_var[0] != '0');
}
else
print = all_mask;
if (sevlevel_var != NULL)
{
__libc_lock_lock (lock);
while (sevlevel_var[0] != '0')
{
const char *end = __strchrnul (sevlevel_var, ':');
int level;
/* First field: keyword.  This is not used here but it must be
present.  */
while (sevlevel_var < end)
if (*sevlevel_var++ == ',')
break;
if (sevlevel_var < end)
{
/* Second field: severity level, a number.  */
char *cp;
level = strtol (sevlevel_var, &cp, 0);
if (cp != sevlevel_var && cp < end && *cp++ == ','
&& level > MM_INFO)
{
const char *new_string;
new_string = __strndup (cp, end - cp);
if (new_string != NULL
&& (internal_addseverity (level, new_string)
!= MM_OK))
free ((char *) new_string);
}
}
sevlevel_var = end + (*end == ':' ? 1 : 0);
}
__libc_lock_unlock (lock);
}
}
/* Add the new entry to the list.  */
static int
internal_addseverity (int severity, const char *string)
{
struct severity_info *runp, *lastp;
int result = MM_OK;
/* First see if there is already a record for the severity level.  */
for (runp = severity_list, lastp = NULL; runp != NULL; runp = runp->next)
if (runp->severity == severity)
break;
else
lastp = runp;
if (runp != NULL)
{
if (string != NULL)
/* Change the string.  */
runp->string = string;
else
{
/* Remove the severity class.  */
if (lastp == NULL)
severity_list = runp->next;
else
lastp->next = runp->next;
free (runp);
}
}
else if (string != NULL)
{
runp = malloc (sizeof (*runp));
if (runp == NULL)
result = MM_NOTOK;
else
{
runp->severity = severity;
runp->next = severity_list;
runp->string = string;
severity_list = runp;
}
}
else
/* We tried to remove a non-existing severity class.  */
result = MM_NOTOK;
return result;
}
/* Add new severity level or remove old one.  */
int
__addseverity (int severity, const char *string)
{
int result;
/* Prevent illegal SEVERITY values.  */
if (severity <= MM_INFO)
return MM_NOTOK;
/* Protect the global data.  */
__libc_lock_lock (lock);
/* Do the real work.  */
result = internal_addseverity (severity, string);
/* Release the lock.  */
__libc_lock_unlock (lock);
return result;
}
weak_alias (__addseverity, addseverity)
libc_freeres_fn (free_mem)
{
struct severity_info *runp = severity_list;
while (runp != NULL)
if (runp->severity > MM_INFO)
{
/* This is data we have to release.  */
struct severity_info *here = runp;
runp = runp->next;
free (here);
}
else
runp = runp->next;
}
-------------------------------------- 
----------------------------------------------------- 
<<CODE_c>>
[CODE_c](../fills/fmtmsg_h/CODE_c)


[UP](###UP)
## H_CODE_m
:fmtmsg.h:
[next](##H_BOOKS)

<<CODE_m>>
[CODE_m](../fills/fmtmsg_h/CODE_m)


[UP](###UP)
## H_BOOKS
:fmtmsg.h:
[next](##H_BOOKS_ru)

<<BOOKS>>
[BOOKS](../fills/fmtmsg_h/BOOKS)


[UP](###UP)
## H_BOOKS_ru
:fmtmsg.h:
[next](##H_SUBSTANCES)

<<BOOKS_ru>>
[BOOKS_ru](../fills/fmtmsg_h/BOOKS_ru)


[UP](###UP)
## H_SUBSTANCES
:fmtmsg.h:
[UP](###UP)
p[fmtmsg](../utils/fmtmsg/fmtmsg.man)
c[MM_PRINT](../consts/MM_PRINT/MM_PRINT.man)
c[MM_CONSOLE](../consts/MM_CONSOLE/MM_CONSOLE.man)
c[MM_HARD](../consts/MM_HARD/MM_HARD.man)
c[MM_FIRM](../consts/MM_FIRM/MM_FIRM.man)
c[MM_SOFT](../consts/MM_SOFT/MM_SOFT.man)
c[MM_APPL](../consts/MM_APPL/MM_APPL.man)
c[MM_UTIL](../consts/MM_UTIL/MM_UTIL.man)
c[MM_OPSYS](../consts/MM_OPSYS/MM_OPSYS.man)
c[MM_RECOVER](../consts/MM_RECOVER/MM_RECOVER.man)
c[MM_NRECOV](../consts/MM_NRECOV/MM_NRECOV.man)
c[MM_NOSEV](../consts/MM_NOSEV/MM_NOSEV.man)
c[MM_HALT](../consts/MM_HALT/MM_HALT.man)
c[MM_ERROR](../consts/MM_ERROR/MM_ERROR.man)
c[MM_WARNING](../consts/MM_WARNING/MM_WARNING.man)
c[MM_INFO](../consts/MM_INFO/MM_INFO.man)
c[MM_OK](../consts/MM_OK/MM_OK.man)
c[MM_NOTOK](../consts/MM_NOTOK/MM_NOTOK.man)
c[MM_NOMSG](../consts/MM_NOMSG/MM_NOMSG.man)
c[MM_NOCON](../consts/MM_NOCON/MM_NOCON.man)
c[MSGVERB](../consts/MSGVERB/MSGVERB.man)
c[SEV_LEVEL](../consts/SEV_LEVEL/SEV_LEVEL.man)
