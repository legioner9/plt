## MmJo56

Вызывая функцию fork(), программа создает свой дубликат, называемый дочерним
процессом. Родительский процесс продолжает выполнять программу с той точки, где была
вызвана функция fork(). То же самое делает и дочерний процесс.
Как же различить между собой оба процесса? Во-первых, дочерний процесс это новый,
только что появившийся в системе процесс, поэтому его идентификатор отличается от
идентификатора родительского процесса. Таким образом, программа может вызвать функцию
getpid() и узнать, где именно она находится. Но сама функция fork() реализует другой способ:
она возвращает разные значения в родительском и дочернем процессах. Родительский процесс
получает идентификатор своего потомка, а дочернему процессу возвращается 0. В системе нет
процессов с нулевым идентификатором, так что программа легко разбирается в ситуации.
В листинге 3.3 приведен пример ветвления программы с помощью функции fork().
Учтите, что первая часть инструкции if выполняется только в родительском процессе, тогда как
ветвь else только в дочернем.
Листинг 3.3. (fork.c) Ветвление