### UP
[poll.h](##poll.h)
[MAIN](##MAIN)
[MAIN_ru](##MAIN_ru)
[ANCORS](##ANCORS)
[ISU](##ISU)
[inet](##A_inet)
[inet](##books_inet)
[inet](##examples_inet)
[inet](##classic_inet)
[inet](##enters_inet)
[inet](##issue_code_inet)
[H_FILE](##H_FILE)
[H_SYNOPSIS](##H_SYNOPSIS)
[H_BUGS](##H_BUGS)
[H_DESCRIPTION_ru](##H_DESCRIPTION_ru)
[H_DESCRIPTION](##H_DESCRIPTION)
[H_ERRORS](##H_ERRORS)
[H_MIRRORS](##H_MIRRORS)
[H_EXAMPLES](##H_EXAMPLES)
[H_CODE_h](##H_CODE_h)
[H_CODE_c](##H_CODE_c)
[H_CODE_m](##H_CODE_m)
[H_BOOKS](##H_BOOKS)
[H_BOOKS_ru](##H_BOOKS_ru)
[H_SUBSTANCES](##H_SUBSTANCES)

[cat_hfiles](../cat_hfiles.md)
[cat_utils](../cat_utils.md)
[cat_structs](../cat_structs.md)
[cat_param](../cat_params.md)
[cat_macros](../cat_macross.md)
[cat_const](../cat_consts.md)
[cat_type](../cat_types.md)
[cat_any](../cat_anys.md)

[UP](###UP)
## MAIN
:poll.h:
[next](##MAIN_ru)

----------------------------------------------------- 
-------------------------------------- 
definitions for the poll() function
-------------------------------------- 
----------------------------------------------------- 
<<MAIN>>
[MAIN](../fills/poll_h/MAIN)


[UP](###UP)
## MAIN_ru
:poll.h:
[next](##ANCORS)

<<MAIN_ru>>
[MAIN_ru](../fills/poll_h/MAIN_ru)


[UP](###UP)
## ANCORS
:poll.h:
[next](##ISU)

<<ANCORS>>
[ANCORS](../fills/poll_h/ANCORS)


[UP](###UP)
## ISU
:poll.h:
[next](##H_FILE)

<<ISU>>
only read
:poll.h:
[ISU](../contents)
[next](##inet)


[UP](###UP)
## inet
:poll.h:
[next](##H_FILE)

[UP](###UP)
## A_inet
[manpages.org](https://www.google.ru/search?q=poll.h+site%3Ahttps%3A%2F%2Fmanpages.org)
[reposcope.com_ru](https://www.google.ru/search?q=poll.h+site%3Ahttps%3A%2F%2Freposcope.com%2Fmanpages%2Fru)
[pubs.opengroup.org](https://www.google.com/search?q=poll.h+https%3A%2F%2Fpubs.opengroup.org)
[manpages.debian.org](https://yandex.ru/search/?text=poll.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[www.opennet.ru](http://www.opennet.ru/man.shtml?category=2&topic=poll.h)
[man7.org](https://www.google.ru/search?q=poll.h+site%3Ahttps%3A%2F%2Fman7.org%2Flinux%2Fman-pages)
[en.cppreference.com](https://www.google.com/search?q=poll.h+en.cppreference.com)
[www.mankier.com](https://www.mankier.com/?q=poll.h)
[www.codecogs.com](https://www.google.ru/search?q=poll.h+https%3A%2F%2Fwww.codecogs.com%2Flibrary%2Fcomputing%2F)
[digitalmars.com](https://www.google.ru/search?q=poll.h+https%3A%2F%2Fdigitalmars.com%2Frtl%2F)


[UP](###UP)
## books_inet
[cpp.com.ru](https://yandex.ru/search/?text=poll.h+site%3Ahttps%3A%2F%2Fcpp.com.ru)
[linuxhint.com](https://www.google.ru/search?q=poll.h+site%3Ahttps%3A%2F%2Flinuxhint.com)
[gnu.org](https://www.google.ru/search?q=poll.h+site%3Ahttps%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2Fmanual)

[UP](###UP)
## examples_inet
[yandex:examples](https://yandex.ru/search/?text=poll.h+example+in+c)
[docs.oracle.com](https://www.google.com/search?q=poll.h+https%3A%2F%2Fdocs.oracle.com)
[manpages.debian.org](https://yandex.ru/search/?text=poll.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[osr507doc.xinuos.com](https://www.google.com/search?q=poll.h+http%3A%2F%2Fosr507doc.xinuos.com%2Fen%2Fman)
[cpp.hotexamples.com](https://cpp.hotexamples.com/examples/-/-/poll.h/cpp-poll.h-function-examples.html)
[all-ht.ru](https://yandex.ru/search/?text=poll.h+site%3Ahttp%3A%2F%2Fall-ht.ru%2Finf%2Fprog%2Fc%2F)
[cppreference.com](https://yandex.ru/search/?text=poll.h+site%3Ahttps%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2F)

[UP](###UP)
## classic_inet
[bogatyrev_c_unix](https://www.google.com/search?q=poll.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fbogatyrev_c_unix)
[kr_cbook](https://www.google.com/search?q=poll.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fkr_cbook)

[UP](###UP)
## enters_inet
[pubs.opengroup.org](https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html)

[UP](###UP)
## issue_code_inet
[code.woboq.org](https://www.google.com/search?h=&sitesearch=https%3A%2F%2Fcode.woboq.org%2Fuserspace%2Fglibc%2F&q=poll.h)


[UP](###UP)
## H_FILE [poll_h.md](poll_h.md)
:poll.h:
[next](##H_SYNOPSIS)

[UP](###UP)
## H_SYNOPSIS
:poll.h:
[next](##H_DESCRIPTION_ru)

<<SYNOPSIS>>
[SYNOPSIS](../fills/poll_h/SYNOPSIS)


[UP](###UP)
## H_DESCRIPTION_ru
:poll.h:
[next](##H_DESCRIPTION)

<<DESCRIPTION_ru>>
[DESCRIPTION_ru](../fills/poll_h/DESCRIPTION_ru)


[UP](###UP)
## H_DESCRIPTION
:poll.h:
[next](##H_ERRORS)

<<DESCRIPTION>>
[DESCRIPTION](../fills/poll_h/DESCRIPTION)


[UP](###UP)
## H_ERRORS
:poll.h:
[next](##H_MIRRORS)

<<ERRORS>>
[ERRORS](../fills/poll_h/ERRORS)


[UP](###UP)
## H_MIRRORS
:poll.h:
[next](##H_BUGS)

<<MIRRORS>>
[MIRRORS](../fills/poll_h/MIRRORS)


[UP](###UP)
## H_BUGS
:poll.h:
[next](##H_EXAMPLES)

<<BUGS>>
[BUGS](../fills/poll_h/BUGS)


[UP](###UP)
## H_EXAMPLES
:poll.h:
[next](##H_CODE)

----------------------------------------------------- 
-------------------------------------- 
https://manpages.debian.org/bullseye/manpages-dev/ppoll.2.en.html
Приведенная ниже программа открывает каждый из файлов, указанных в ее аргументах командной строки, и отслеживает результирующие файловые дескрипторы на предмет готовности к чтению (POLLIN). Программа повторяет цикл, повторно используя poll() для мониторинга файловых дескрипторов, печатая количество готовых файловых дескрипторов при возврате. Для каждого готового файлового дескриптора программа:
отображает возвращенное поле revents в удобочитаемой форме;
если дескриптор файла доступен для чтения, считывает из него некоторые данные и отображает эти данные в стандартном выводе; и
если файловые дескрипторы были недоступны для чтения, но произошло какое-то другое событие (предположительно, ОПРОС), дескриптор файла закрывается.
Предположим, мы запускаем программу в одном терминале, прося ее открыть FIFO:
$ mkfifo myfifo
$ ./poll_input myfifo
Затем во втором окне терминала мы открываем FIFO для записи, записываем в него некоторые данные и закрываем FIFO:
$ echo aaaaabbbbcccccc > myfifo
Затем в терминале, где мы запускаем программу, мы увидим:
Opened "myfifo" on fd 3
About to poll()
Ready: 1
fd=3; events: POLLIN POLLHUP
read 10 bytes: aaaaabbbbb
About to poll()
Ready: 1
fd=3; events: POLLIN POLLHUP
read 6 bytes: ccccc
About to poll()
Ready: 1
fd=3; events: POLLHUP
closing fd 3
All file descriptors closed; bye
В приведенном выше выводе мы видим, что функция poll() возвращается три раза:
При первом возврате биты, возвращенные в поле revents, были POLLIN, что указывает на то, что дескриптор файла доступен для чтения, и POLLHUP, что указывает на то, что другой конец FIFO был закрыт. Затем программа использовала часть доступных входных данных.
Во втором возврате из poll() также указаны POLLIN и POLLHUP; затем программа использовала последний из доступных входных данных.
При окончательном возврате функция poll() указала только POLLHUP в FIFO, после чего дескриптор файла был закрыт, и программа завершилась.
/* poll_input.c
Licensed under GNU General Public License v2 or later.
anys/
consts/
contents/
fills/
hfiles/
listh/
_lists/
params/
src/
structs/
types/
utils/
#include <poll.h>
#include <fcntl.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); 
} while (0)
int
main(int argc, char *argv[])
{
int nfds, num_open_fds;
struct pollfd *pfds;
if (argc < 2) {
fprintf(stderr, "Usage: %s file...
", argv[0]);
exit(EXIT_FAILURE);
}
num_open_fds = nfds = argc - 1;
pfds = calloc(nfds, sizeof(struct pollfd));
if (pfds == NULL)
errExit("malloc");
/* Open each file on command line, and add it 'pfds' array */
for (int j = 0; j < nfds; j++) {
pfds[j].fd = open(argv[j + 1], O_RDONLY);
if (pfds[j].fd == -1)
errExit("open");
printf("Opened "%s" on fd %d
", argv[j + 1], pfds[j].fd);
pfds[j].events = POLLIN;
}
/* Keep calling poll() as long as at least one file descriptor is
open */
while (num_open_fds > 0) {
int ready;
printf("About to poll()
");
ready = poll(pfds, nfds, -1);
if (ready == -1)
errExit("poll");
printf("Ready: %d
", ready);
/* Deal with array returned by poll() */
for (int j = 0; j < nfds; j++) {
char buf[10];
if (pfds[j].revents != 0) {
printf("  fd=%d; events: %s%s%s
", pfds[j].fd,
(pfds[j].revents & POLLIN)  ? "POLLIN "  : "",
(pfds[j].revents & POLLHUP) ? "POLLHUP " : "",
(pfds[j].revents & POLLERR) ? "POLLERR " : "");
if (pfds[j].revents & POLLIN) {
ssize_t s = read(pfds[j].fd, buf, sizeof(buf));
if (s == -1)
errExit("read");
printf("    read %zd bytes: %.*s
",
s, (int) s, buf);
} else {                /* POLLERR | POLLHUP */
printf("    closing fd %d
", pfds[j].fd);
if (close(pfds[j].fd) == -1)
errExit("close");
num_open_fds--;
}
}
}
}
printf("All file descriptors closed; bye
");
exit(EXIT_SUCCESS);
}
-------------------------------------- 
----------------------------------------------------- 
<<EXAMPLES>>
[EXAMPLES](../fills/poll_h/EXAMPLES)


[UP](###UP)
## H_CODE_h
:poll.h:
[next](##H_CODE_c)

<<CODE_h>>
[CODE_h](../fills/poll_h/CODE_h)


[UP](###UP)
## H_CODE_c
:poll.h:
[next](##H_CODE_m)

<<CODE_c>>
[CODE_c](../fills/poll_h/CODE_c)


[UP](###UP)
## H_CODE_m
:poll.h:
[next](##H_BOOKS)

<<CODE_m>>
[CODE_m](../fills/poll_h/CODE_m)


[UP](###UP)
## H_BOOKS
:poll.h:
[next](##H_BOOKS_ru)

<<BOOKS>>
[BOOKS](../fills/poll_h/BOOKS)


[UP](###UP)
## H_BOOKS_ru
:poll.h:
[next](##H_SUBSTANCES)

<<BOOKS_ru>>
[BOOKS_ru](../fills/poll_h/BOOKS_ru)


[UP](###UP)
## H_SUBSTANCES
:poll.h:
[UP](###UP)
p[poll](../utils/poll/poll.man)
p[ppoll](../utils/ppoll/ppoll.man)
t[nfds_t](../types/nfds_t/nfds_t.man)
s[pollfd](../structs/pollfd/pollfd.man)
