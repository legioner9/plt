### UP
[assert.h](##assert.h)
[MAIN](##MAIN)
[MAIN_ru](##MAIN_ru)
[ANCORS](##ANCORS)
[ISU](##ISU)
[inet](##A_inet)
[inet](##books_inet)
[inet](##examples_inet)
[inet](##classic_inet)
[inet](##enters_inet)
[inet](##issue_code_inet)
[H_FILE](##H_FILE)
[H_SYNOPSIS](##H_SYNOPSIS)
[H_BUGS](##H_BUGS)
[H_DESCRIPTION_ru](##H_DESCRIPTION_ru)
[H_DESCRIPTION](##H_DESCRIPTION)
[H_ERRORS](##H_ERRORS)
[H_MIRRORS](##H_MIRRORS)
[H_EXAMPLES](##H_EXAMPLES)
[H_CODE_h](##H_CODE_h)
[H_CODE_c](##H_CODE_c)
[H_CODE_m](##H_CODE_m)
[H_BOOKS](##H_BOOKS)
[H_BOOKS_ru](##H_BOOKS_ru)
[H_SUBSTANCES](##H_SUBSTANCES)

[cat_hfiles](../cat_hfiles.md)
[cat_utils](../cat_utils.md)
[cat_structs](../cat_structs.md)
[cat_param](../cat_params.md)
[cat_macros](../cat_macross.md)
[cat_const](../cat_consts.md)
[cat_type](../cat_types.md)
[cat_any](../cat_anys.md)

[UP](###UP)
## MAIN
:assert.h:
[next](##MAIN_ru)

<<MAIN>>
[MAIN](../fills/assert_h/MAIN)


[UP](###UP)
## MAIN_ru
:assert.h:
[next](##ANCORS)

<<MAIN_ru>>
[MAIN_ru](../fills/assert_h/MAIN_ru)


[UP](###UP)
## ANCORS
:assert.h:
[next](##ISU)

<<ANCORS>>
[ANCORS](../fills/assert_h/ANCORS)


[UP](###UP)
## ISU
:assert.h:
[next](##H_FILE)

<<ISU>>
only read
:assert.h:
[ISU](../contents)
[next](##inet)


[UP](###UP)
## inet
:assert.h:
[next](##H_FILE)

[UP](###UP)
## A_inet
[manpages.org](https://www.google.ru/search?q=assert.h+site%3Ahttps%3A%2F%2Fmanpages.org)
[reposcope.com_ru](https://www.google.ru/search?q=assert.h+site%3Ahttps%3A%2F%2Freposcope.com%2Fmanpages%2Fru)
[pubs.opengroup.org](https://www.google.com/search?q=assert.h+https%3A%2F%2Fpubs.opengroup.org)
[manpages.debian.org](https://yandex.ru/search/?text=assert.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[www.opennet.ru](http://www.opennet.ru/man.shtml?category=2&topic=assert.h)
[man7.org](https://www.google.ru/search?q=assert.h+site%3Ahttps%3A%2F%2Fman7.org%2Flinux%2Fman-pages)
[en.cppreference.com](https://www.google.com/search?q=assert.h+en.cppreference.com)
[www.mankier.com](https://www.mankier.com/?q=assert.h)
[www.codecogs.com](https://www.google.ru/search?q=assert.h+https%3A%2F%2Fwww.codecogs.com%2Flibrary%2Fcomputing%2F)
[digitalmars.com](https://www.google.ru/search?q=assert.h+https%3A%2F%2Fdigitalmars.com%2Frtl%2F)


[UP](###UP)
## books_inet
[cpp.com.ru](https://yandex.ru/search/?text=assert.h+site%3Ahttps%3A%2F%2Fcpp.com.ru)
[linuxhint.com](https://www.google.ru/search?q=assert.h+site%3Ahttps%3A%2F%2Flinuxhint.com)
[gnu.org](https://www.google.ru/search?q=assert.h+site%3Ahttps%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2Fmanual)

[UP](###UP)
## examples_inet
[yandex:examples](https://yandex.ru/search/?text=assert.h+example+in+c)
[docs.oracle.com](https://www.google.com/search?q=assert.h+https%3A%2F%2Fdocs.oracle.com)
[manpages.debian.org](https://yandex.ru/search/?text=assert.h+site%3Ahttps%3A%2F%2Fmanpages.debian.org%2F)
[osr507doc.xinuos.com](https://www.google.com/search?q=assert.h+http%3A%2F%2Fosr507doc.xinuos.com%2Fen%2Fman)
[cpp.hotexamples.com](https://cpp.hotexamples.com/examples/-/-/assert.h/cpp-assert.h-function-examples.html)
[all-ht.ru](https://yandex.ru/search/?text=assert.h+site%3Ahttp%3A%2F%2Fall-ht.ru%2Finf%2Fprog%2Fc%2F)
[cppreference.com](https://yandex.ru/search/?text=assert.h+site%3Ahttps%3A%2F%2Fen.cppreference.com%2Fw%2Fc%2F)

[UP](###UP)
## classic_inet
[bogatyrev_c_unix](https://www.google.com/search?q=assert.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fbogatyrev_c_unix)
[kr_cbook](https://www.google.com/search?q=assert.h+site%3Ahttps%3A%2F%2Fcpp.com.ru%2Fkr_cbook)

[UP](###UP)
## enters_inet
[pubs.opengroup.org](https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html)

[UP](###UP)
## issue_code_inet
[code.woboq.org](https://www.google.com/search?h=&sitesearch=https%3A%2F%2Fcode.woboq.org%2Fuserspace%2Fglibc%2F&q=assert.h)


[UP](###UP)
## H_FILE [assert_h.md](assert_h.md)
:assert.h:
[next](##H_SYNOPSIS)

[UP](###UP)
## H_SYNOPSIS
:assert.h:
[next](##H_DESCRIPTION_ru)

<<SYNOPSIS>>
[SYNOPSIS](../fills/assert_h/SYNOPSIS)


[UP](###UP)
## H_DESCRIPTION_ru
:assert.h:
[next](##H_DESCRIPTION)

<<DESCRIPTION_ru>>
[DESCRIPTION_ru](../fills/assert_h/DESCRIPTION_ru)


[UP](###UP)
## H_DESCRIPTION
:assert.h:
[next](##H_ERRORS)

<<DESCRIPTION>>
[DESCRIPTION](../fills/assert_h/DESCRIPTION)


[UP](###UP)
## H_ERRORS
:assert.h:
[next](##H_MIRRORS)

<<ERRORS>>
[ERRORS](../fills/assert_h/ERRORS)


[UP](###UP)
## H_MIRRORS
:assert.h:
[next](##H_BUGS)

<<MIRRORS>>
[MIRRORS](../fills/assert_h/MIRRORS)


[UP](###UP)
## H_BUGS
:assert.h:
[next](##H_EXAMPLES)

<<BUGS>>
[BUGS](../fills/assert_h/BUGS)


[UP](###UP)
## H_EXAMPLES
:assert.h:
[next](##H_CODE)

<<EXAMPLES>>
[EXAMPLES](../fills/assert_h/EXAMPLES)


[UP](###UP)
## H_CODE_h
:assert.h:
[next](##H_CODE_c)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/assert/assert.h.html
/afs
/bin
/boot
/dev
/etc
/home
/lib
/lib64
/lost+found
/media
/mnt
/opt
/proc
/root
/run
/sbin
/srv
/sys
/tmp
/usr
/var
*        ISO C99 Standard: 7.2 Diagnostics        <assert.h>
*/
#ifdef        _ASSERT_H
# undef        _ASSERT_H
# undef        assert
# undef __ASSERT_VOID_CAST
# ifdef        __USE_GNU
#  undef assert_perror
# endif
#endif /* assert.h        */
#define        _ASSERT_H        1
#include <features.h>
#if defined __cplusplus && __GNUC_PREREQ (2,95)
# define __ASSERT_VOID_CAST static_cast<void>
#else
# define __ASSERT_VOID_CAST (void)
#endif
/* void assert (int expression);
If NDEBUG is defined, do nothing.
If not, and EXPRESSION is zero, print an error message and abort.  */
#ifdef        NDEBUG
# define assert(expr)                (__ASSERT_VOID_CAST (0))
/* void assert_perror (int errnum);
If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
error message with the error text for ERRNUM and abort.
(This is a GNU extension.) */
# ifdef        __USE_GNU
#  define assert_perror(errnum)        (__ASSERT_VOID_CAST (0))
# endif
#else /* Not NDEBUG.  */
__BEGIN_DECLS
/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (const char *__assertion, const char *__file,
unsigned int __line, const char *__function)
__THROW __attribute__ ((__noreturn__));
/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, const char *__file,
unsigned int __line, const char *__function)
__THROW __attribute__ ((__noreturn__));
/* The following is not at all used here but needed for standard
compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
__THROW __attribute__ ((__noreturn__));
__END_DECLS
/* When possible, define assert so that it does not add extra
parentheses around EXPR.  Otherwise, those added parentheses would
suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */
# if defined __cplusplus
#  define assert(expr)                                                        
(static_cast <bool> (expr)                                                
? void (0)                                                        
: __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
# elif !defined __GNUC__ || defined __STRICT_ANSI__
#  define assert(expr)                                                        
((expr)                                                                
? __ASSERT_VOID_CAST (0)                                                
: __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
# else
/* The first occurrence of EXPR is not evaluated due to the sizeof,
but will trigger any pedantic warnings masked by the __extension__
for the second occurrence.  The ternary operator is required to
support function pointers and bit fields in this context, and to
suppress the evaluation of variable length arrays.  */
#  define assert(expr)                                                        
((void) sizeof ((expr) ? 1 : 0), __extension__ ({                        
if (expr)                                                                
; /* empty */                                                        
else                                                                
__assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);        
}))
# endif
# ifdef        __USE_GNU
#  define assert_perror(errnum)                                                
(!(errnum)                                                                
? __ASSERT_VOID_CAST (0)                                                
: __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))
# endif
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
which contains the name of the function currently being defined.
This is broken in G++ before version 2.6.
C9x has a similar variable called __func__, but prefer the GCC one since
it demangles C++ function names.  */
# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
#   define __ASSERT_FUNCTION        __extension__ __PRETTY_FUNCTION__
# else
#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#   define __ASSERT_FUNCTION        __func__
#  else
#   define __ASSERT_FUNCTION        ((const char *) 0)
#  endif
# endif
#endif /* NDEBUG.  */
#if defined __USE_ISOC11 && !defined __cplusplus
# undef static_assert
# define static_assert _Static_assert
#endif
-------------------------------------- 
----------------------------------------------------- 
<<CODE_h>>
[CODE_h](../fills/assert_h/CODE_h)


[UP](###UP)
## H_CODE_c
:assert.h:
[next](##H_CODE_m)

----------------------------------------------------- 
-------------------------------------- 
https://code.woboq.org/userspace/glibc/assert/assert.c.html
#include <assert.h>
#include <atomic.h>
#include <ldsodefs.h>
#include <libintl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sysdep.h>
#include <unistd.h>
#include <sys/mman.h>
extern const char *__progname;
#include <wchar.h>
#include <libio/iolibio.h>
#define fflush(s) _IO_fflush (s)
/* This function, when passed a string containing an asserted
expression, a filename, and a line number, prints a message
on the standard error stream of the form:
a.c:10: foobar: Assertion `a == b' failed.
It then aborts program execution via a call to `abort'.  */
#ifdef FATAL_PREPARE_INCLUDE
# include FATAL_PREPARE_INCLUDE
#endif
void
__assert_fail_base (const char *fmt, const char *assertion, const char *file,
unsigned int line, const char *function)
{
char *str;
#ifdef FATAL_PREPARE
FATAL_PREPARE;
#endif
int total;
if (__asprintf (&str, fmt,
__progname, __progname[0] ? ": " : "",
file, line,
function ? function : "", function ? ": " : "",
assertion, &total) >= 0)
{
/* Print the message.  */
(void) __fxprintf (NULL, "%s", str);
(void) fflush (stderr);
total = (total + 1 + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
struct abort_msg_s *buf = __mmap (NULL, total, PROT_READ | PROT_WRITE,
MAP_ANON | MAP_PRIVATE, -1, 0);
if (__glibc_likely (buf != MAP_FAILED))
{
buf->size = total;
strcpy (buf->msg, str);
/* We have to free the old buffer since the application might
catch the SIGABRT signal.  */
struct abort_msg_s *old = atomic_exchange_acq (&__abort_msg, buf);
if (old != NULL)
__munmap (old, old->size);
}
free (str);
}
else
{
/* At least print a minimal message.  */
static const char errstr[] = "Unexpected error.
";
__libc_write (STDERR_FILENO, errstr, sizeof (errstr) - 1);
}
abort ();
}
#undef __assert_fail
void
__assert_fail (const char *assertion, const char *file, unsigned int line,
const char *function)
{
__assert_fail_base (_("%s%s%s:%u: %s%sAssertion `%s' failed.
%n"),
assertion, file, line, function);
}
hidden_def(__assert_fail)
-------------------------------------- 
----------------------------------------------------- 
<<CODE_c>>
[CODE_c](../fills/assert_h/CODE_c)


[UP](###UP)
## H_CODE_m
:assert.h:
[next](##H_BOOKS)

<<CODE_m>>
[CODE_m](../fills/assert_h/CODE_m)


[UP](###UP)
## H_BOOKS
:assert.h:
[next](##H_BOOKS_ru)

<<BOOKS>>
[BOOKS](../fills/assert_h/BOOKS)


[UP](###UP)
## H_BOOKS_ru
:assert.h:
[next](##H_SUBSTANCES)

<<BOOKS_ru>>
[BOOKS_ru](../fills/assert_h/BOOKS_ru)


[UP](###UP)
## H_SUBSTANCES
:assert.h:
[UP](###UP)
p[assert](../utils/assert/assert.man)
