<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- saved from url=(0047)http://opennet.ru/docs/RUS/ansi-c/ansi-c-8.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=KOI8-R">

 <meta name="GENERATOR" content="SGML-Tools 1.0.9">
 <title> Описание языка программирования ANSI C. : Директивы препроцессора и Прагмы </title>
 <link href="http://opennet.ru/docs/RUS/ansi-c/ansi-c-7.html" rel="previous">
 <link href="http://opennet.ru/docs/RUS/ansi-c/ansi-c.html#toc8" rel="contents">
</head>
<body bgcolor="#DDE1C2">
<link rel="stylesheet" href="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="http://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="http://opennet.ru/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>) <span style="text-decoration: line-through red;"><a href="https://www.opennet.ru/docs/RUS/ansi-c/ansi-c-8.html" title="Страница открыта без HTTPS">HTTPS</a></span>

</div>

<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tbody><tr>
<td width="300" valign="BOTTOM" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left">
<a href="http://opennet.ru/"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/opennet2.gif" height="60" width="249" alt="The OpenNET Project" border="0"></a><br>
</td>
<td width="100" align="CENTER" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left">

</td><td width="50%" align="CENTER" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;padding-bottom:10px;">
<table width="100%" border="0">
<tbody><tr>
<td width="22%">
 <a href="https://www.opennet.ru/opennews/" class="h"><b>НОВОСТИ</b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <a href="https://www.opennet.ru/mp/" class="h"><b>КОНТЕНТ</b></a>
</td><td width="14%">
  <a href="http://wiki.opennet.ru/" class="h"><b>WIKI</b></a>
</td><td width="14%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b>MAN'ы</b></a>
</td><td width="16%">
   <a href="https://www.opennet.ru/forum/" class="h"><b>ФОРУМ</b></a>
</td><td width="16%">
<a href="https://www.opennet.ru/search.shtml" class="h" onmouseover="document.getElementById(&#39;form12&#39;).style.display=&#39;block&#39;;">Поиск</a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>)
<input id="form12" style="display: none;" type="text" size="10" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;">
</td></tr>
</tbody></table>

</td><td align="right" width="20%" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;padding-bottom:5px;">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/rss.png" height="16" width="16" alt="RSS" title="RSS" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/twitter.png" height="16" width="16" alt="twitter" title="Twitter" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/vkontakte.gif" height="16" width="16" title="ВКонтакте" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/zen.gif" height="16" width="16" title="Yandex Zen" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/facebook.gif" height="16" width="16" title="Facebook" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/telegram2.png" height="16" width="16" title="Telegram" border="0"></a>
</td></tr></tbody></table>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="http://opennet.ru/"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="http://opennet.ru/opennews/">новости</a>&nbsp;/<a href="http://opennet.ru/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="http://opennet.ru/forum/">форум</a> | <a href="http://wiki.opennet.ru/">wiki</a> | <a href="http://opennet.ru/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/telegram2.png" height="16" width="16" title="Telegram" border="0" style="margin-bottom: -4px;"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv">
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->


<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin-bottom: 5px;margin-top: 5px;">
<tbody><tr><td>
<table border="0" cellspacing="0" cellpadding="4" bgcolor="#E9EAD6" width="100%">
<tbody><tr bgcolor="#C7CBB1"><td><font color="#000090">
<b><a href="http://www.opennet.ru/docs/">Каталог документации</a> / 
<a href="http://www.opennet.ru/docs/124.shtml">Раздел "Программирование, языки"</a> /
<a href="http://www.opennet.ru/docs/RUS/ansi-c/">Оглавление документа</a>
</b>
</font></td></tr>
</tbody></table>
</td></tr>
<tr bgcolor="#B0B190"><td><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/p.gif" height="3" width="1" alt=""></td></tr>
</tbody></table>

Вперед
<a href="http://opennet.ru/docs/RUS/ansi-c/ansi-c-7.html">Назад</a>
<a href="http://opennet.ru/docs/RUS/ansi-c/ansi-c.html#toc8">Содержание</a>
<hr>
<h2><a name="s8">8. Директивы препроцессора и Прагмы </a></h2>

<p>   
</p><p>   
</p><h2><a name="ss8.1">8.1 Введение </a>
</h2>

<p>   
Директивы предпроцессора это инструкции предпроцессору С.   
Предпроцессор С это текстовый процессор, который манипулирует   
текстом исходного файла на первой фазе компиляции. Хотя   
компилятор вызывает предпроцессор на своей первой стадии, его   
можно вызвать и отдельно для обработки текста без компилирования.   
</p><p>   
Директивы предпроцессора обычно используются для облегчения   
внесения изменений в исходные программы и для облегчения их   
компилирования в разных средах выполнения. Расположенные в   
исходном файле директивы заставляют предпроцессор выполнять   
конкретные действия. Например, предпроцессор может заменить   
лексемы в тексте, вставить содержимое других файлов в исходный   
файл или подавить компиляцию части файла, удаляя сегменты текста.   
</p><p>   
Предпроцессор С распознает следующие директивы:   
</p><p>   
</p><blockquote><code>
<pre>           #define        #if            #line   
           #elif          #ifdef         #undef   
           #else          #ifndef   
           #endif         #include   
</pre>
</code></blockquote>
   
Знак номера (#) должен быть первым неразделительным символом   
на строке, содержащей директиву, между символом номера и первой   
буквой директивы могут появляться разделительные символы.   
Некоторые директивы содержат аргументы или значения. Любой текст,   
который следует за директивой (кроме аргумента или значения,   
который является частью директивы) должен быть заключен в скобки   
комментария (/* */).   
<p>   
Директивы предпроцессора могут появляться в произвольном   
месте исходного файла, но они будут воздействовать только на   
оставшуюся часть исходного файла, в котором они появились.   
</p><p>   
"Оператор предпроцессора" это оператор, который признается   
оператором только в контексте директив предпроцессора. Есть   
только три специфические оператора предпроцессора: "строковый"   
(#), "вставки лексем" (##) и defined. Первые два оператора будут   
рассмотрены в данной Главе позднее в контексте директивы #define.   
Оператор defined также будет позже рассмотрен в данной Главе в   
Разделе "Директивы #if, #elif, #else и #endif".   
</p><p>   
"Прагма" это "прагматическая", или практическая, инструкция   
компилятору С. Прагмы в исходном файле С обычно используются для   
управления действиями компилятора над конкретной частью программы   
без воздействия на программу в целом. (Синтаксис прагм рассмотрен   
в Разделе 8.6.) Однако, доступность и предназначение отдельных   
прагм определяется конкретной реализацией компилятора. Информацию   
об использовании и действии конкретных прагм можно найти в Вашем   
Руководстве по компилятору.   
</p><p>   
</p><p>   
</p><p>   
</p><h2><a name="ss8.2">8.2 Объявленные константы и Макросы </a>
</h2>

<p>   
Директива #define обычно используется для организации связи   
содержательных идентификаторов с константами, ключевыми словами и   
часто используемыми операторами и выражениями. Представляющие   
константы идентификаторы называются "объявленными константами".   
Представляющие операторы или выражения константы называются   
"макросами".   
</p><p>   
После определения идентификатора его нельзя переопределить   
для другого значения, если не удалить первоначальное определение.   
Однако, можно переопределить идентификатор тем же самым   
определением. Следовательно, одно определение может появиться в   
программе несколько раз.   
</p><p>   
Директива #undef удаляет определение идентификатора. После   
удаления определения идентификатор можно переопределить другим   
значением. Директивы #define и #undef рассматриваются   
соответственно в Разделах 8.2.2 и 8.2.3.   
</p><p>   
Практически можно выделить два типа макросов. "Объектные"   
макросы не принимают аргументов, а "функциональные" определены   
таким образом, что принимают аргументы, и выглядят и действуют   
подобно вызовам функций. Макросы не генерируют действительные   
вызовы функций, поэтому программа будет работать быстрее, если   
заменить вызовы функций макросами. Однако, макросы могут создать   
свои проблемы, если не подойти к их определению и использованию   
со всей тщательностью. В определении макросов с аргументами   
возможно придется воспользоваться скобками для установления   
надлежащего порядка проведения вычислений в выражениях. Кроме   
того, макросы могут некорректно обработать выражения с побочными   
эффектами. Дополнительную информацию можно увидеть в примерах   
Раздела 8.2.2, "Директива #define".   
</p><p>   
</p><p>   
</p><p>   
</p><h3>Операторы предпроцессора </h3>

<p>   
Есть три специфических оператора предпроцессора: один   
представлен знаком номера (#), другой удвоенным знаком номера   
(##), а третий словом defined. "Строковый" оператор (#), который   
предшествует имени формального параметра макро, заставляет   
предпроцессор заключить соответствующий действительный аргумент в   
строковые цитатные скобки. Оператор "вставки лексем" (##)   
позволяет осуществить слияние лексем, заданных в качестве   
действительных аргументов, в форму другой лексемы. Эти два   
оператора используются в контексте директивы #define и описаны в   
Разделах 8.2.2.1 и 8.2.2.2.   
</p><p>   
И, наконец, оператор defined упрощает написание составных   
выражений в некоторых директивах макро. Он используется при   
условной компиляции и поэтому рассмотрен в Разделе 8.4.1   
"Директивы #if, #elif, #else и #endif".   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><h3>Директива #define </h3>

<p>   
</p><blockquote><code>
<pre>      Синтаксис: #define идентификатор текст-замены   
                 #define идентификатор(список-параметров)   
                     текст-замены   
</pre>
</code></blockquote>
   
Директива #define заменяет все появления "идентификатор" в   
исходном файле на "текст-замены". Идентификатор заменяется   
только тогда, когда он формирует лексему. (Лексемы описаны в   
Главе "Элементы языка С" и "Кратком обзоре синтаксиса".)   
Например, идентификатор не будет заменен, если он появляется в   
строке или как часть более длинного идентификатора.   
<p>   
Если после идентификатора следует список параметров, то   
директива #define заменит каждое появление   
идентификатор(список-параметров) на версию аргумента текст-замены   
в которой формальные параметры заменены на действительные   
аргументы.   
</p><p>   
Аргумент "текст-замены" состоит из ряда лексем, таких как   
ключевые слова, константы или полные операторы. Один или   
несколько разделительных символов должны отделять текст-замены от   
идентификатора (или от закрывающей скобки списка параметров). Эти   
разделительные символы не считаются частью текста-замены, также   
как и любые разделительные символы, которые следуют за последней   
лексемой текста. Текст, занимающий более одной строки, может быть   
продолжен на следующей строке, если до символа перехода на новую   
строку поместить знак обратного деления (\).   
</p><p>   
Аргумент текст-замены может быть пустым. Выбор этой опции   
удаляет все появления идентификатора из исходного файла. Однако,   
идентификатор все еще считается определенным и дает значение 1   
при его проверке директивой #if (рассматривается в Разделе   
8.4.1).   
</p><p>   
Необязательный список параметров состоит из одного или   
нескольких имен формальных параметров, разделенных запятыми.   
Каждое имя списка должно быть уникальным и весь список должен   
быть заключен в скобки. Нельзя ставить пробел между   
идентификатором и открывающей скобкой. Сфера действия формального   
параметра распространяется до той строки, которая заканчивает   
текст-замены.   
</p><p>   
Имена формальных параметров появляются в тексте-замены для   
того, чтобы пометить места, куда будут вставлены действительные   
значения. Имя формального параметра может появляться в тексте   
замены несколько раз и имена могут следовать в произвольном   
порядке.   
</p><p>   
Действительные аргументы, которые следуют за появлениями   
идентификатора в исходном файле совпадают с соответствующими   
формальными параметрами списка параметров. Каждый формальный   
параметр в тексте замены, которому не предшествует оператор # или   
##, или за которым следует оператор ##, будет заменен   
соответствующим действительным аргументом. Все макросы   
действительного аргумента будут раскрыты до замены ими формального   
параметра. (Операторы # и ## описаны в Разделах 8.2.2.1 и   
8.2.2.2.) Список действительных аргументов должен иметь столько   
аргументов, сколько их в списке параметров.   
</p><p>   
Если имя определенного макро появляется в тексте замены   
(даже в результате раскрытия другого макро), то оно не   
раскрывается.   
</p><p>   
Аргументы с побочными эффектами иногда вынуждают макро   
выдавать неожиданные результаты. Заданный формальный параметр   
может появиться в тексте замены несколько раз. Если формальный   
параметр заменяется выражением с побочным эффектом, то выражение,   
с его побочным эффектом, будет вычисляться несколько раз. (См.   
Пример 4 в Разделе 8.2.2.2, "Оператор вставки лексем".   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
Строковый оператор (#)   
</p><p>   
Знак номера или строковый оператор (#) используется только с   
макросами, которые принимают аргументы. Если в определении макро   
он предшествует формальному параметру, то передаваемый при вызове   
макро действительный аргумент заключается в цитатные скобки и   
обрабатывается как строковый литерал. Затем строковый литерал   
заменяет каждое появление комбинации строкового оператора и   
формального параметра в определении макро. Предшествующие первой   
лексеме действительного аргумента разделительные символы и   
следующие за последней лексемой действительного аргумента   
разделительные символы игнорируются. В результирующем строковом   
литерале разделительные символы между лексемами действительного   
аргумента сокращаются до одного. Следовательно, если между двумя   
лексемами действительного аргумента есть комментарий, он будет   
сокращен до одного разделительного символа. Результирующий   
строковый литерал автоматически сливается с любым соседним   
строковым литералом от которого он разделен лишь разделительным   
символом. Более того, если аргумент содержит символ, который   
обычно требует управляющей последовательности для использования в   
качестве строкового литерала - например, цитатная скобка (") или   
знак обратного деления (\) - то перед этим символом будет   
автоматически вставлен необходимый для управляющей   
последовательности знак обратного деления. Следующий пример   
показывает определение макро, которое содержит строковый оператор,   
и функцию main, которая вызывает это макро:   
</p><p>   
</p><blockquote><code>
<pre> #define stringer(x) printf(#x "\n")   
   
  main()   
  {   
   stringer (I will be in quotes in the printf function call);   
   stringer ("I will be in quotes when printed to the screen");   
   stringer (This: \" prints an escaped double quote mark);   
  }   
</pre>
</code></blockquote>
   
<p>   
</p><p>   
В результате предпроцессорной обработки получим следующий   
код:   
</p><p>   
</p><blockquote><code>
<pre> printf("I will be in quotes in the printf function call" "\n");   
 printf("\"I will be in quotes when printed to the screen\"" "\n");   
 printf(This: \\\" prints an escaped double quote mark");   
</pre>
</code></blockquote>
   
При работе программы на экран выведется следующий текст:   
<p>   
</p><blockquote><code>
<pre>      I will be in quotes in the printf function call   
      "I will be in quotes when printed to the screen"   
      This: \" prints an escaped double quote mark   
</pre>
</code></blockquote>
   
<p>   
Оператор вставки лексем (##)   
</p><p>   
Удвоенный знак номера или оператор "вставки лексем" (##)   
используется и в объектный и в функциональных макро. Он позволяет   
объединять отдельные лексемы в единую лексему и следовательно не   
может быть первой или последней лексемой в определении макро.   
</p><p>   
Если до или после формального параметра в определении макро   
стоит оператор вставки лексем, то формальный параметр немедленно   
заменяется на нераскрытый действительный аргумент. Раскрытие   
макро не производится над аргументом до его замены. Затем все   
появления оператора с тексте замены удаляются и предшествующие и   
последующие им лексемы объединяются. Результирующая лексема   
должна быть корректной. Если это так, то лексема просматривается   
на возможную замену, если она содержит имя макро. Пример 7   
показывает, как лексемы могут быть вставлены вместе с   
использованием оператора вставки лексем.   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
Пример 1   
</p><p>   
В данном примере определяется идентификатор WIDTH как целая   
константа 80, в терминах WIDTH определяется LENGTH и целая   
константа 10. Каждое появление LENGTH заменяется на (WIDTH + 10).   
В свою очередь, каждое появление WIDTH + 10 заменяется выражением   
(80+10).   
</p><p>   
</p><blockquote><code>
<pre>           #define WIDTH  80   
           #define LENGTH (WIDTH + 10)   
</pre>
</code></blockquote>
   
Замыкающие WIDTH + 10 скобки очень важны, т.к. они управляют   
интерпретацией операторов, подобных следующему:   
<p>   
</p><blockquote><code>
<pre>           var = LENGTH * 20;   
</pre>
</code></blockquote>
   
После стадии предпроцессорной обработки этот оператор будет   
выглядеть так:   
<p>   
</p><blockquote><code>
<pre>           var = (80 + 10) * 20;   
</pre>
</code></blockquote>
   
что даст в результате 1800. Без скобок результат будет 280:   
<p>   
</p><blockquote><code>
<pre>           var = 80 + 10 * 20;   
</pre>
</code></blockquote>
   
<p>   
Пример 2   
</p><p>   
В данном примере определяется идентификатор FILEMESSAGE. Его   
определение расширяется на вторую строку использованием символа   
обратного деления, за которым следует символ новой строки.   
</p><p>   
</p><blockquote><code>
<pre>      #define FILEMASSAGE "Attempt to create file \   
      failed because of insufficient space"   
</pre>
</code></blockquote>
   
<p>   
</p><p>   
</p><p>   
Пример 3   
</p><p>   
В данном примере определяются три идентификатора: REG1, REG2   
и REG3. REG1 и REG2 определяются как ключевое слово register.   
Определение REG3 пусто, поэтому из исходного файла будет удалены   
все появления REG3. Эти директивы можно использовать для того,   
чтобы убедиться в том, что наиболее важные переменные программы   
(объявленные с REG1 и REG2) заданы с классом хранения register.   
(Расширенную версию данного примера можно найти при рассмотрении   
директивы #if в Разделе 8.4.1.)   
</p><p>   
</p><blockquote><code>
<pre>           #define REG1   register   
           #define REG2   register   
           #define REG3   
</pre>
</code></blockquote>
   
<p>   
Пример 4   
</p><p>   
В данном примере определяется макро с именем MAX. После   
этого определения все появления идентификатора MAX в исходном   
файле будут заменены на выражение   
</p><p>   
</p><blockquote><code>
<pre>           ((x) &gt; (y)) ? (x) : (y)   
</pre>
</code></blockquote>
   
где действительные значения заменят параметры x и y. Например,   
появление   
<p>   
</p><blockquote><code>
<pre>           MAX(1,2)   
</pre>
</code></blockquote>
   
будет заменено на   
<p>   
</p><blockquote><code>
<pre>           ((1) &gt; (2)) ? (1) : (2)   
</pre>
</code></blockquote>
   
и появление   
<p>   
</p><blockquote><code>
<pre>           MAX(i,s[i])   
</pre>
</code></blockquote>
   
будет заменено на   
<p>   
</p><blockquote><code>
<pre>           ((i) &gt; (s[i])) ? (i) : (s[i])   
</pre>
</code></blockquote>
   
<p>   
</p><blockquote><code>
<pre>           #define MAX(x,y)    ((x) &gt; (y)) ? (x) : (y)   
</pre>
</code></blockquote>
   
<p>   
Макро легче читается, чем соответствующее выражение, поэтому   
легче понять исходный текст программы.   
</p><p>   
Обратите внимание на то, что аргументы с побочными эффектами   
могут дать неожиданные результаты при выполнении макро. Например,   
появление MAX(i, s[i++]) будет заменено на ((i)&gt;(s[i++]))?(i):   
(s[i++]). Выражение (s[i++]) может быть вычислено дважды, поэтому   
после вычисления тернарного оператора i может быть увеличено   
единожды или дважды, в зависимости от результатов сравнения.   
</p><p>   
</p><p>   
Пример 5   
</p><p>   
В данном примере определяется макро MULT. После определения   
этого макро появление выражений подобных MULT(3,5) будет заменены   
на (3)*(5). Скобки вокруг параметров важны, т.к. управление   
интерпретацией сложных выражений формирует аргументы макро.   
Например, появление MULT(3+4,5+6) будет заменено на (3+4)*(5+6),   
что даст в результате 77. Без скобок получаем 3+4*5+6, или 29,   
т.к. оператор умножения (*) имеет приоритет выше, чем оператор   
сложения (+).   
</p><p>   
</p><blockquote><code>
<pre>           #define MULT(a,b)   ((a) * (b))   
</pre>
</code></blockquote>
   
<p>   
Пример 6   
</p><p>   
В данном примере определяются два макро. Объектное макро   
раскрывается в строковый литерал Hello,Word!, а другое   
функциональное макро вызывает show, которое берет один аргумент.   
Однако, определение второго макро включает строковый оператор   
(#), который непосредственно предшествует формальному параметру   
x. При передаче аргумента в макро show формальный параметр будет   
заменен действительным аргументом, заключенным в двойные цитатные   
скобки.   
</p><p>   
</p><blockquote><code>
<pre>           #define GREETING Hello, World!   
           #define show(x) printf(#x)   
   
           main()   
           {   
                show(x+z);   
                printf("\n");   
                show(n /* some comment */ + p);   
                printf("\n");   
                show(GREETING); /* GREETING не раскрыто; */   
                printf("\n");   /* вместо этого отработал */   
                show ('\x');    /* строковый оператор */   
                }   
</pre>
</code></blockquote>
   
По мере обработки предпроцессором исходного файла ссылки на   
show будут раскрыты так:   
<p>   
</p><blockquote><code>
<pre>      show (x+z); даст printf("x+z");   
      show (n/*ccomment*/+p); даст printf("n+p");   
      show (GREETING); даст printf("GREETING");   
      show ('\x'); даст printf("'\\x'");   
</pre>
</code></blockquote>
   
При работе программы на экран будет выведено:   
<p>   
</p><blockquote><code>
<pre>      x+z   
      n+p   
      GREETING   
      '\x'   
</pre>
</code></blockquote>
   
<p>   
</p><p>   
</p><p>   
</p><p>   
Пример 7   
</p><p>   
Данный пример показывает использование строкового оператора   
и оператора вставки лексем для организации вывода программы.   
</p><p>   
</p><blockquote><code>
<pre>      #define paster(n) printf("token" #n " = %d", token##n)   
</pre>
</code></blockquote>
   
Если объявлен token9 и макро вызывается с числовым аргументом,   
подобно:   
<p>   
</p><blockquote><code>
<pre>           paster(9);   
</pre>
</code></blockquote>
   
то макро преобразуется в вид:   
<p>   
</p><blockquote><code>
<pre>           printf("token" "9" " = %d", token9);   
</pre>
</code></blockquote>
   
который станет   
<p>   
</p><blockquote><code>
<pre>           printf("token9 = %d", token9);   
</pre>
</code></blockquote>
   
<p>   
</p><p>   
</p><h3>Директива #undef </h3>

<p>   
</p><blockquote><code>
<pre>      Синтаксис:     #undef идентификатор   
</pre>
</code></blockquote>
   
Директива #undef удаляет текущее определение идентификатора.   
Поэтому все встречающиеся появления идентификатора будут   
игнорироваться предпроцессором. Для удаления определения макро с   
использованием #undef, нужно задать только идентификатор макро,   
не задавая список параметров.   
<p>   
Можно применить директиву #undef к идентификатору, у   
которого нет определения. Тем самым пользователь получает   
дополнительную гарантию того, что данный идентификатор не   
определен.   
</p><p>   
Директива #undef обычно используется в паре с директивой   
#define для задания области исходной программы, в которой   
идентификатор имеет специальное значение. Например, некоторая   
функция исходной программы может иметь объявленные константы,   
которые задают значения среды работы, которые не влияют на   
остальную часть программы. Директива #undef также работает с   
директивой #if (см. Раздел 8.4.1) для управления условной   
компиляцией исходной программы.   
</p><p>   
</p><p>   
Пример   
</p><p>   
В данном примере директива #undef удаляет определения   
объявленных констант и макро. Обратите внимание на то, что   
задается только идентификатор макро.   
</p><p>   
</p><blockquote><code>
<pre>           #define WIDTH  80   
           #define ADD(X,Y)    (X) + (Y)   
           .   
           .   
           .   
           #undef WIDTH   
           #undef ADD   
</pre>
</code></blockquote>
   
<p>   
</p><p>   
</p><h2><a name="ss8.3">8.3 Включаемые файлы </a>
</h2>

<p>   
</p><blockquote><code>
<pre>      Синтаксис:     #include "спецификация-пути"   
                     #include &lt;спецификация-пути&gt;   
</pre>
</code></blockquote>
v   
Директива #include добавляет содержимое заданного файла в   
другой файл. Можно организовать определения констант и макро в   
отдельном файле, а затем вставить его директивой #include в любой   
другой файл. Вставка файлов также очень удобна для объединения   
объявлений внешних переменных и сложных типов данных. Нужно   
определить и задать имена этих типов только один раз в созданный   
для этих целей файл.   
<p>   
Директива #include информирует предпроцессор о том, что   
содержание файла с заданным именем следует обрабатывать так, как   
будто оно присутствует в исходной программе в месте расположения   
этой директивы. Новый текст также может содержать директивы   
предпроцессора. Предпроцессор выполняет директивы в новом тексте,   
а затем продолжает обработку текста исходного файла.   
</p><p>   
"Спецификация пути" это имя файла, которому может   
предшествовать директория. Это должно быть имя существующего   
файла. Синтаксис спецификации файла зависит от операционной   
системы, в которой компилируется программа.   
</p><p>   
При поиске файлов предпроцессор использует концепцию   
"стандартной" директории. Расположение стандартных директорий для   
файлов зависит от реализации и операционной системы. Определение   
стандартной директории можно найти в Вашем Руководстве по   
компилятору.   
</p><p>   
Предпроцессор останавливает поиск сразу же после обнаружения   
файла с заданным именем. Если задать полную спецификацию файла,   
заключенную в двойные цитатные скобки (" "), то предпроцессор   
использует ее для поиска и игнорирует стандартную директорию.   
</p><p>   
Если заключенная в двойные цитатные скобки спецификация   
файла является неполной, то предпроцессор сначала ищет директорию   
"родительского" файла. Родительский файл это файл, содержащий   
директиву #include. Например, если файл fil2 вставляется в файл   
fil1, то fil1 будет родительским файлом.   
</p><p>   
Вставка файлов может быть вложенной. Т.е. директива #include   
может появляться в файле, который сам вставляется директивой   
#include. Например, в приведенном выше примере файл fil2 может   
вызывать файл fil3. В этом случае fil1 все еще будет родительским   
для fil2, но "дедушкой" для fil3.   
</p><p>   
При вложенной вставке файлов поиск директории начинается с   
родительского файла, затем проходит по дедушкиным файлам.   
Следовательно, поиск начинается в директории, которая содержит   
обрабатываемый исходный файл. Если файл не найден, то поиск   
продолжается в директориях, заданных в командной строке   
компилятора. И, наконец, производится поиск в стандартной   
директории.   
</p><p>   
Если спецификация файла заключена в угловые скобки, то   
предпроцессор не проводит поиска в текущем рабочем каталоге.   
Поиск файла начинается в директориях, заданный в командной строке   
компилятора, а затем в стандартной директории.   
</p><p>   
Допускается вложение вставки файлов до 10 уровней. При   
обработке вложенных #include предпроцессор всегда будет   
осуществлять вставку в первоначальный исходный файл.   
</p><p>   
</p><p>   
Пример 1   
</p><p>   
В данном примере содержимое файла с именем stdio.h будет   
вставлено в исходную программу. Угловые скобки заставляют   
предпроцессор искать stdio.h в стандартной директории, после   
поиска в директориях, указанных в командной строке.   
</p><p>   
</p><blockquote><code>
<pre>                #include &lt;stdio.h&gt;   
</pre>
</code></blockquote>
   
<p>   
Пример 2   
</p><p>   
Данный пример добавит в исходный файл содержимое файла   
defs.h. Двойные цитатные скобки означают, что предпроцессор   
начнет поиск в родительском каталоге.   
</p><p>   
</p><blockquote><code>
<pre>                #include "defs.h"   
</pre>
</code></blockquote>
   
<p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><h2><a name="ss8.4">8.4 Условная компиляция </a>
</h2>

<p>   
Данный раздел описывает синтаксис и использование директив,   
которые управляют "условной компиляцией". Эти директивы позволяют   
подавить компиляцию части исходного файла, проверяя постоянное   
выражение или идентификатор. Результат проверки определяет, какие   
блоки текста будут переданы в компилятор и какие блоки текста   
будут удалены из исходного файла при предпроцессорной обработке.   
</p><p>   
</p><p>   
</p><p>   
</p><h3>Директивы #if, #elif, #else и #endif </h3>

<p>   
</p><blockquote><code>
<pre>      Синтаксис:     #if граничное-постоянное-выражение   
                          [блок-текста]   
                     [#elif граничное-постоянное-выражение   
                          блок-текста]   
                     [#elif граничное-постоянное-выражение   
                          блок-текста]   
                     .   
                     .   
                     .   
                     [#else   
                          блок-текста]   
                     #endif   
</pre>
</code></blockquote>
   
Директива #if вместе с директивами #elif, #else и #endif   
управляют компиляцией части исходного файла. Каждая директива #if   
в исходном файле должна иметь соответствующую закрывающую   
директиву #endif. Между директивами #if и #endif может появиться   
любое число директив #elif, но допускается наличие только одной   
директивы #else. Если имеется директива #else, то она должна быть   
последней директивой перед #endif.   
<p>   
Предпроцессор выбирает одно из заданных появлений блока   
текста для дальнейшей обработки. Этот блок может быть любой   
последовательностью текста. Он может занимать несколько строк.   
Обычно блок текста это текст программы, который имеет значение   
для компилятора или предпроцессора.   
</p><p>   
Предпроцессор обрабатывает выбранный блок текста и передает   
его компилятору. Если блок текста содержит директивы   
предпроцессора, то предпроцессор выполнит эти директивы.   
</p><p>   
Все блоки текста, не выбранные предпроцессором, удаляются из   
обрабатываемого файла. Следовательно, эти блоки текста не   
компилируются.   
</p><p>   
Предпроцессор выбирает отдельный блок текста вычисляя   
выражение граничной константы, которое следует за каждой   
директивой #if или #elif, пока результатом выражения граничной   
константы не будет "истина" (не ноль). Выбирается весь текст   
(включая начинающиеся с # другие директивы предпроцессора) до   
соответствующего #elif, #else или #endif.   
</p><p>   
Если значением всех выражений граничных констант будет   
"ложь", или нет директивы #elif, то предпроцессор выберет блок   
текста после предложения #else. Если предложения #else нет, то   
блок вообще не выбирается.   
</p><p>   
Каждое выражение граничной константы соответствует правилам   
Раздела 5.2.10. Эти выражения не могут содержать выражений   
sizeof, приведения типа или перечислимых констант. Однако, они   
могут содержать оператор предпроцессора defined в специальном   
постоянном выражении, имеющем следующий синтаксис:   
</p><p>   
</p><blockquote><code>
<pre>                defined(идентификатор)   
</pre>
</code></blockquote>
   
Это постоянное выражение будет иметь значение "истина" (не   
ноль), если заданный идентификатор определен, в противном случае   
- "ложь" (0). Идентификатор, определенный как пустой текст,   
считается определенным.   
<p>   
Директивы #if, #elif, #else и #endif могут быть вложены в   
другие директивы #if. Каждая вложенная директива #else, #elif или   
#endif принадлежит к ближайшей к ней директиве #if.   
</p><p>   
</p><p>   
Пример 1   
</p><p>   
В данном примере директивы #if и #endif управляют   
компиляцией одного из трех вызовов функции. Вызов функции credit   
компилируется, если определен идентификатор CREDIT. Если   
определен идентификатор DEBIT, то компилируется вызов функции   
debit. Если не определен ни один из идентификаторов, то   
компилируется вызов printerror. Обратите внимание на то, что   
CREDIT и credit это разные идентификаторы в языке С.   
</p><p>   
</p><blockquote><code>
<pre>           #if defined(CREDIT)   
                credit();   
           #elif defined(DEBIT)   
                debit();   
           #else   
                printerror();   
           #end   
</pre>
</code></blockquote>
   
<p>   
Пример 2   
</p><p>   
Примеры 2 и 3 предполагают наличие ранее определенной   
константы с именем DLEVEL.   
</p><p>   
Пример 2 показывает два вложенных набора директив #if, #else   
и #endif. Первый набор директив будет обработан только если   
значение DLEVEL&gt;5 "истина". В противном случае будет обработан   
второй набор директив.   
</p><p>   
</p><blockquote><code>
<pre>           #if DLEVEL&gt;5   
                #define SIGNAL 1   
                #if STACKUSE == 1   
                     #define STACK 200   
                #else   
                     #define STACK 100   
                #endif   
           #else   
                #define SIGNAL 0   
                #if STACKUSE == 1   
                     #define STACK 100   
                #else   
                     #define STACK 50   
                #endif   
           #endif   
</pre>
</code></blockquote>
v   
<p>   
Пример 3   
</p><p>   
В примере 3 директивы #elif и #else применятся для того,   
чтобы сделать выбор одного из четырех вариантов на основании   
значения DLEVEL. Объявленная константа STACK устанавливается в 0,   
100 или 200 в зависимости от определения DLEVEL. Если DLEVEL   
больше 5, то компилируется display(debugptr); и STACK не   
определяется.   
</p><p>   
</p><blockquote><code>
<pre>           #if DLEVEL == 0   
                #define STACK 0   
           #elif DLEVEL == 1   
                #define STACK 100   
           #elif DLEVEL &gt; 5   
                display(debugptr);   
           #else   
                #define STACK 200   
           #endif   
</pre>
</code></blockquote>
   
<p>   
Пример 4   
</p><p>   
В данном примере директивы предпроцессора используются для   
управления значением объявления register в мобильном исходном   
файле. Компилятор выделяет регистровую память переменным в той   
последовательности, в которой объявления register появляются в   
исходном файле. Если в программе присутствуют больше объявлений   
register, чем допускает компьютер, то компилятор дает приоритет   
более ранним объявлениям над более поздними. Программа может   
стать менее эффективной, если наиболее часто используемые   
переменные объявлены слишком поздно.   
</p><p>   
</p><blockquote><code>
<pre>           #define REG1 register   
           #define REG2 register   
   
           #if defined(M_86)   
                #define REG3   
                #define REG4   
                #define REG5   
   
           #else   
                #define REG3 register   
                #if defined(M_68000)   
                     #define REG4 register   
                     #define REG5 register   
                #else   
                     #define REG4 register   
                     #define REG5   
                #endif   
           #endif   
</pre>
</code></blockquote>
   
Приведенные в Примере 4 определения можно использовать для   
задания высшего приоритета наиболее важным объявлениям регистров.   
REG1 и REG2 определены с ключевым словом register и для этих двух   
наиболее важных переменных программы выделяется регистровая   
память. Например, в следующем фрагменте b и c имеют приоритет   
выше, чем a и d:   
<p>   
</p><blockquote><code>
<pre>                func(a)   
 
                REG3 int a;   
   
                {   
                     REG1 int b;   
                     REG2 int c;   
                     REG4 int d;   
                     .   
                     .   
                     .   
                }   
</pre>
</code></blockquote>
   
Если определен M_86, то предпроцессор удалит идентификатор   
REG3 из файла, заменив его пустым текстом. а не будет выделена   
регистровая память за счет b и с. Если задан M_68000, то всем   
четырем переменным выделяется регистровая память. Если не задан   
ни М_86 ни М_68000, то регистровая память выделяется а, b и с.   
<p>   
</p><p>   
</p><h3>Директивы #ifdef и #ifndef </h3>

<p>   
</p><blockquote><code>
<pre>      Синтаксис:     #ifdef идентификатор   
                     #ifndef идентификатор   
</pre>
</code></blockquote>
   
Директивы #ifdef и #ifndef выполняют те же функции, что и   
директива #if с defined(идентификатор). Директивы #ifdef и   
#ifndef можно использовать везде, где допустимо использование   
#if. Эти директивы реализованы только для обеспечения   
совместимости с предыдущими версиями языка. Предпочтительно   
использовать постоянное выражение defined(идентификатор) c   
с директивой #if.   
<p>   
Когда предпроцессор обнаруживает директиву #ifdef, он   
проверяет, определен ли идентификатор. Если это так, то значение   
условия "истина" (не ноль), и "ложь" (0) в противном случае.   
</p><p>   
Директива #ifndef проверяет условие, противоположное условию   
#ifdef. Если идентификатор не определен (или его определение   
удалено с помощью #undef), то условие "истина", и "ложь" (0) в   
противном случае.   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><h2><a name="ss8.5">8.5 Управление Line </a>
</h2>

<p>   
</p><blockquote><code>
<pre>      Синтаксис:     #line константа["имя-файла"]   
</pre>
</code></blockquote>
   
Директива #line дает команду компилятору сменить хранимые им   
номер строки и имя файла на данные. Компилятор использует номер   
строки и имя файла для указания ошибок, которые он обнаруживает   
при компиляции. Номер строки обычно соответствует текущей строке,   
а имя файла - текущему файлу. После обработки каждой строки номер   
строки увеличивается.   
<p>   
Если сменить номер строки и имя файла, то компилятор   
игнорирует предыдущие значения и продолжит обработку с новыми   
значениями. Директива #line обычно используется генераторами   
программ для появления сообщений об ошибках в исходном тексте, а   
не в генерируемой программе.   
</p><p>   
Константа в директиве #line может быть любой целой   
константой. Имя файла может быть любой комбинацией символов,   
заключенной в двойные цитатные скобки. Если имя файла не задано,   
то предыдущее имя файла остается без изменения.   
</p><p>   
Всегда имеется доступ к текущему номеру строки и имени файла   
через заранее определенные идентификаторы __LINE__ и __FILE__.   
Эти идентификаторы можно использовать в самодокументирующихся   
сообщения об ошибках, помещенных в текст программы.   
</p><p>   
Идентификатор __FILE__ раскрывается в строку, содержимое   
которой есть имя файла, заключенное в двойные цитатные скобки.   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
</p><p>   
Пример 1   
</p><p>   
В данном примере хранимый номер строки меняется на 151, а   
имя файла меняется на copy.c .   
</p><p>   
</p><blockquote><code>
<pre>                #line 151 "copy.c"   
</pre>
</code></blockquote>
   
<p>   
Пример 2   
</p><p>   
В данном примере макро ASSERT использует ранее определенные   
идентификаторы __LINE__ и __FILE__ для печати сообщения об ошибке   
в исходном файле, если значение условия "ложь".   
</p><p>   
</p><blockquote><code>
<pre>           #define ASSERT(cond)     if(!cond)\   
           {printf("assertion error line %d, file(%s)\n",\   
           __LINE__, __FILE__ );} else   
</pre>
</code></blockquote>
   
<p>   
</p><h2><a name="ss8.6">8.6 Прагмы </a>
</h2>

<p>   
</p><blockquote><code>
<pre>      Синтаксис:     #pragma последовательность-символов   
</pre>
</code></blockquote>
   
#pragma это инструкция компилятору, которая определяется   
реализацией. Последовательность символов задает конкретную   
инструкцию компилятору и аргументы, если они есть. Знак номера   
(#) должен быть первым неразделительным символом на строке,   
содержащей прагму. Между знаком номера и словом pragma могут   
стоять разделительные символы.   
<p>   
Информация об имеющихся в реализации Вашего компилятора   
прагмах содержится в Вашем Руководстве по компилятору.   
</p><hr>
Вперед
<a href="http://opennet.ru/docs/RUS/ansi-c/ansi-c-7.html">Назад</a>
<a href="http://opennet.ru/docs/RUS/ansi-c/ansi-c.html#toc8">Содержание</a>

<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height:60px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height:60px;  line-height:60px; margin-left: 20px;">
<a style="align: middle;" target="_blank" href="https://inferno.name/"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/inferno2.png" height="57" width="200" alt="Inferno Solutions"></a>
</div>
<div style="float:right; height:60px;  line-height:60px;  margin-left: 15px;">
<a style="align: middle;" target="_blank" href="http://hoster.ru/?utm_source=site&amp;utm_medium=banner&amp;utm_campaign=opennet"><img src="./Описание языка программирования ANSI C. _ Директивы препроцессора и Прагмы_files/dh143x60t.png" height="60" width="143" alt="Hosting by Hoster.ru"></a>
</div>
<div style="float:right;  height:60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>
<div style="clear: both;"></div>


<br>
<table class="ttxt" style="border-top: 3px solid #C9CaB6;">
<tbody><tr><td width="35%">
<a href="http://opennet.ru/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</a><br>
<a href="http://opennet.ru/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</a>
</td>
<td width="65%" align="RIGHT">
Created&nbsp;1996-2022&nbsp;by <b><a href="http://opennet.ru/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</a></b><br>
<a href="https://www.opennet.ru/add.shtml">Добавить</a>, <a href="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</a>, <a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>
</td>
</tr>
</tbody></table>
<br><br>


<!--/htdig_noindex-->
<!-- end of footer -->
<!--
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>
-->




</body><style id="stylus-1" type="text/css" class="stylus">body {
    font-family: 'pragmata pro mono regular';
}</style></html>